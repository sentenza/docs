<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="sentenza">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Scala - Sentenza's notes</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Scala";
    var mkdocs_page_input_path = "scala.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Sentenza's notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Scala</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#evaluation-rules">Evaluation rules</a></li>
    

    <li class="toctree-l2"><a href="#objects-and-code-organization">Objects and Code organization</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#general-object-hierarchy">General object hierarchy:</a></li>
        
            <li><a class="toctree-l3" href="#type-parameters">Type Parameters</a></li>
        
            <li><a class="toctree-l3" href="#variance">Variance</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#collections">Collections</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#pairs-similar-for-larger-tuples">Pairs (similar for larger Tuples)</a></li>
        
            <li><a class="toctree-l3" href="#ordering">Ordering</a></li>
        
            <li><a class="toctree-l3" href="#map-and-flatmap">map() and flatMap()</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#category-theory">Category Theory</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#algrebraic-data-type">Algrebraic Data Type</a></li>
        
            <li><a class="toctree-l3" href="#typeclass">Typeclass</a></li>
        
            <li><a class="toctree-l3" href="#monoid">Monoid</a></li>
        
            <li><a class="toctree-l3" href="#fold-foldright-and-foldleft">fold: foldRight() and foldLeft()</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../links/">Links</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Sentenza's notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Scala</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/sentenza/docs/edit/master/docs/scala.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="evaluation-rules">Evaluation rules</h2>
<ul>
<li><code>def</code> defines a method</li>
<li><code>val</code> defines a fixed value, it is immmutable and eagerly initialized</li>
<li><code>var</code> defines a variable reference, it is mutable and it should be avoided</li>
<li><code>lazy</code> only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters</li>
</ul>
<pre><code class="scala">    def myFunction = 2         // evaluated when called
    val myImmutableValue = 2   // evaluated immediately
    lazy val iMLazy = 2        // evaluated once when needed

    def sort(x: List[Double])       // call by value
    def sort(x: =&gt; List[Double])    // call by name
    // ds is a sequence of Double, containing a varying number of arguments
    def varargsFunction(ds: Double*) = ???
</code></pre>

<ul>
<li><strong>Call by-value</strong>: evaluates the function arguments before calling the function</li>
<li><strong>Call by-name</strong>: evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function)</li>
</ul>
<h1 id="objects-and-code-organization">Objects and Code organization</h1>
<blockquote>
<p><em>Scala has no globally visible methods: every method must be contained in an object or a class. However, using methods named <code>apply</code> inside global objects, you can support usage patterns that look like invocations of global methods.</em></p>
</blockquote>
<p>From <a href="https://www.artima.com/shop/programming_in_scala"><em>Programming in Scala - Second edition (by M. Odersky, L. Spoon, B. Venners)</em></a></p>
<p>As you can see above, I started talking about Objects in terms of the functions they contain. It's very important to stress on this aspect, because Classes and Objects should be seen under a different light using Scala, especially if you come from an imperative OOP language, like Java or C++. They are just a way to organise your functions and at some point, using traits, objects (companion objects) and case classes (data constructors) you will eventually be able to build up your coding architecture based on types and composition of functions.</p>
<p><strong>Factory Object</strong></p>
<p>This example is taken from <a href="https://www.artima.com/shop/programming_in_scala">Programming in Scala</a></p>
<pre><code class="scala">abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length
    def width: Int = if (height == 0) 0 else contents(0).length
}

class ArrayElements(val contents: Array[String]) extends Element 

// Invoking superclass constructor while extending the class itself
class LineElement(s: String) extends ArrayElement(Array(s)) {
    override def width = s.length // Int is inferred
    override def width = 1
}

class UniformElement(
    ch: Char,
    override val width: Int,
    override val heigth: Int
) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}
</code></pre>

<p>Now, what we can do is defining a <em>Factory Object</em> which contains methods that construct other objects, without exposing each class implementation. Basically, we can hide each class inside a Singleton Object, which will represent just a tag for the overloaded methods that will give us the ability to instantiate each subclass dinamically, and using polymorphism at the same time. Note that <strong>OOP is not a paradigm, but it's just a way to define our code structure in a logic manner</strong> that is similar to playing with LEGOs. OOP can be seen like an <strong>orthogonal dimension</strong> compared to functional, declarative or imperative paradigms.</p>
<pre><code class="scala">// We start defining a Singleton Object
object Element {
    // we can now hide classes as private fields of this object
    private class ArrayElements(
        val contents: Array[String]
    ) extends Element

    private class LineElement(s: String) extends Element {
        val contents = Array(s)
        override def width = s.length
        override def width = 1
    }

    private class UniformElement(
        ch: Char,
        override val width: Int,
        override val heigth: Int
    ) extends Element {
        private val line = ch.toString * width
        def contents = Array.fill(height)(line)
    } 

    // FACTORY
    def elem(contents: Array[String]): Element =
        new ArrayElement(contents)

    def elem(chr: Char, width: Int, heigth: Int): Element = 
        new UniformElement(chr, width, height)

    def elem(line: String): Elem =
        new LineElement(line)
}
</code></pre>

<p>Objects creation are centralized and the details now are hidden. This will eventually give an easy way to understand how to use these elements, and at the same time this small change will give the developer the <strong>Open/Closed Principle</strong> for free (<em>“software entities … should be open for extension, but closed for modification”</em>) because less detail is exposed, providing the developer more opportunities to <strong>change the implementation of the library without breaking client code</strong>. At the same time a class will have a single responsibility, and only one potential change in the software’s specification should be able to affect the specification of the class (<strong>Single Responsibility Principle</strong>). Writing <code>SOLID</code> code pays off at the end. </p>
<p><strong>Object and Factory method</strong></p>
<h2 id="general-object-hierarchy">General object hierarchy:</h2>
<p><img alt="scala-hierarchy" src="../assets/img/scala-hierarchy.png" /></p>
<p><strong>NOTE:</strong> All members of packages <code>scala</code> and <code>java.lang</code> as well as all members of the object <code>scala.Predef</code> are automatically imported.</p>
<ul>
<li><code>scala.Nothing</code> is a trait that is the bottom subtype of every subtype of <code>scala.Any</code><ul>
<li><code>scala.Any</code> base type of all types. It has methods <code>hashCode</code> and <code>toString</code> that can be overridden</li>
</ul>
</li>
<li><code>scala.AnyVal</code> is the base type of all primitive types: <code>Double</code>, <code>Float</code>, etc.</li>
<li><code>scala.AnyRef</code> base type of all reference types. (alias of <code>java.lang.Object</code>, supertype of <code>java.lang.String</code>, <code>scala.List</code>, any user-defined class)</li>
<li><code>scala.Null</code> is a subtype of any <code>scala.AnyRef</code>, and <code>scala.Nothing</code> is a subtype of any other type without any instance.<ul>
<li><code>Null</code> is a trait and is the bottom type similiar to <code>Nothing</code> but only for <code>AnyRef</code> not <code>AnyVal</code></li>
<li><code>null</code> is the only instance of type <code>Null</code></li>
</ul>
</li>
<li><code>Nil</code> is an empty list that is defined as a <code>List[Nothing]</code></li>
<li><code>None</code> is an empty option that is defined as a <code>Option[Nothing]</code></li>
<li><code>Unit</code> is a subtype of <code>AnyVal</code>, it's only value is <code>()</code> and it is not represented by any object in the underlying runtime system. A method with return type <code>Unit</code> is analogous to a Java method which is declared <code>void</code></li>
</ul>
<h2 id="type-parameters">Type Parameters</h2>
<p>Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions.</p>
<pre><code class="scala">    class TypedClass[F](arg1: F) { ??? }  
    new TypedClass[Int](1)  
    new TypedClass(1)   // the type is being inferred, i.e. determined based on the value arguments  
</code></pre>

<p>Conventionally, the type parameters are expressed using uppercase letters (e.g. <em>A, B, T, F</em>). It's also possible to restrict the type being used, e.g.</p>
<pre><code class="scala">    def func[T &lt;: TopLevel](arg: T): T = { ... } // T must derive from TopLevel or be TopLevel
    def func[T &gt;: Level1](arg: T): T = { ... }   // T must be a supertype of Level1
    def func[T &gt;: Level1 &lt;: Top Level](arg: T): T = { ... }
</code></pre>

<h2 id="variance">Variance</h2>
<p><strong>Upper Bounds:</strong>
<code>[S &lt;: T]</code> means: S is a subtype of T. Let's suppose that T is actually an <code>Iterable</code>, then S could one of <code>Seq</code>, <code>List</code> or <code>Iterable</code>.</p>
<p><strong>Lower Bounds:</strong>
<code>[S &gt;: T]</code> means: S is a supertype of T, or T is a subtype of S. So, if T is a <code>List</code>, S could be one of <code>List</code>, <code>Seq</code>, <code>Iterable</code>, or <code>AnyRef</code>.</p>
<p><strong>Mixed Bounds:</strong>
<code>[S &gt;: T2 &lt;: T1]</code> means: s is any type on interval between T1 and T2. In this case we have basically a mix of the two cases above.</p>
<p>Let's consider <code>NonEmpty &lt;: IntSet</code>, then can we infer that <code>List[NonEmpty] &lt;: List[IntSet]</code>?
Intuitively, this makes sense: a list of non-empty sets is a special case of a list of arbitrary sets.
We call types for which this relationship holds <strong>covariant</strong> because their subtyping relationship varies with the type parameter. Thus <code>Lists</code> in scala are <strong>covariant</strong>.</p>
<p>Does covariance make sense for all types, not just for List? No. For instance, in Scala, <strong>arrays are not covariant</strong>.
So when does it make sense to subtype one type with another? The answer is the <a href="https://stackoverflow.com/a/584732/1977778">Liskov Substitution Principle</a>: <em>If <code>A &lt;: B</code>, then everything one can to do with a value of
type B one should also be able to do with a value of type A.</em></p>
<p>Say C[T] is a parameterized type, and A, B are types such that:</p>
<ul>
<li>Given <code>A &lt;: B</code> (A is a subtype of B)</li>
<li>If <code>C[A] &lt;: C[B]</code>, <code>C</code> is <strong>covariant</strong></li>
<li>If <code>C[A] &gt;: C[B]</code>, <code>C</code> is <strong>contravariant</strong></li>
<li>Neither <code>C[A]</code> or <code>C[B]</code> is a subtype of the other, then C is <strong>invariant</strong> (or <em>"nonvariant"</em>). </li>
</ul>
<p>Scala lets you declare the variance of a type by annotating the type parameter:</p>
<pre><code class="scala">    class C[+A] { ... } // C is covariant
    class C[-A] { ... } // C is contravariant
    class C[A]  { ... } // C is invariant
</code></pre>

<p>So, given that <code>Any</code> &gt; <code>AnyRef</code> &gt; <code>IntSet</code> &gt; <code>Empty</code> and <code>NonEmpty</code>, if </p>
<pre><code class="scala">type A = IntSet =&gt; NonEmpty
type B = NonEmpty =&gt; IntSet
</code></pre>

<p>According to the <a href="https://stackoverflow.com/a/584732/1977778">Liskov Principle</a> =&gt; <code>A &lt;: B</code>, since B can return an Empty or NonEmpty, but A can return only NonEmpty.</p>
<p>For a function, if <code>A2 &lt;: A1</code> and <code>B1 &lt;: B2</code>, then <code>A1 =&gt; B1 &lt;: A2 =&gt; B2</code>. The consequence is that functions must be <strong>contravariant in their argument types and covariant in their result types</strong>.</p>
<p>This example shows that functions are <em>contravariant</em> in argument types and <em>covariant</em> in return types.</p>
<pre><code class="scala">package io.github.sentenza.cars

class Car {}
class SportsCar extends Car {}
class Ferrari extends SportsCar {}

object morecovariance extends App {

    // Test 1: Works as expected

    def test1( arg: SportsCar =&gt; SportsCar ) = {
        new SportsCar
    }

    def foo1(arg: Car): Ferrari = { new Ferrari }
    def foo2(arg: SportsCar): Car = { new Ferrari }
    def foo3(arg: Ferrari): Ferrari = { new Ferrari }

    test1(foo1) // compiles
    test1(foo2) // Fails due to wrong return type. 
    test1(foo3) // Fails due to wrong parameter type

}
</code></pre>

<p>Find out more about variance in <a href="http://blog.kamkor.me/Covariance-And-Contravariance-In-Scala/">Covariance And Contravariance in Scala</a></p>
<h1 id="collections">Collections</h1>
<p>Scala defines several collection classes:</p>
<p><strong>Base Classes</strong></p>
<ul>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.Iterable"><code>Iterable</code></a> (collections you can iterate on)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.Seq"><code>Seq</code></a> (ordered sequences)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.Set"><code>Set</code></a></li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.Map"><code>Map</code></a> (lookup data structure)</li>
</ul>
<p><strong>Immutable Collections</strong></p>
<ul>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List"><code>List</code></a> (linked list, provides fast sequential access)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream"><code>Stream</code></a> (same as List, except that the tail is evaluated only on demand)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Vector"><code>Vector</code></a> (array-like type, implemented as tree of blocks, provides fast random access)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Range"><code>Range</code></a> (ordered sequence of integers with equal spacing)</li>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><code>String</code></a> (Java type, implicitly converted to a character sequence, so you can treat every string like a <code>Seq[Char]</code>)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map"><code>Map</code></a> (collection that maps keys to values)</li>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set"><code>Set</code></a> (collection without duplicate elements)</li>
</ul>
<p><strong>Mutable Collections</strong></p>
<ul>
<li><a href="http://www.scala-lang.org/api/current/index.html#scala.Array"><code>Array</code></a> (Scala arrays are native JVM arrays at runtime, therefore they are very performant)</li>
<li>Scala also has mutable maps and sets; <strong>these should only be used if there are performance issues with immutable types</strong></li>
</ul>
<p>Examples</p>
<pre><code class="scala">    val r: Range = 1 until 5 // 1, 2, 3, 4
    val s: Range = 1 to 5    // 1, 2, 3, 4, 5
    1 to 10 by 3  // 1, 4, 7, 10
    6 to 1 by -2  // 6, 4, 2

    // Operations on sequences
    val xs = List(...)
    xs.length   // number of elements, complexity O(n)
    xs.last     // last element (exception if xs is empty), complexity O(n)
    xs.init     // all elements of xs but the last (exception if xs is empty), complexity O(n)
    xs take n   // first n elements of xs
    xs drop n   // the rest of the collection after taking n elements
    xs(n)       // the nth element of xs, complexity O(n)
    xs ++ ys    // concatenation, complexity O(n)
    xs.reverse  // reverse the order, complexity O(n)
    xs updated(n, x)  // same list than xs, except at index n where it contains x, complexity O(n)
    xs indexOf x      // the index of the first element equal to x (-1 otherwise)
    xs contains x     // same as xs indexOf x &gt;= 0
    xs filter p       // returns a list of the elements that satisfy the predicate p
    xs filterNot p    // filter with negated p 
    xs partition p    // same as (xs filter p, xs filterNot p)
    xs takeWhile p    // the longest prefix consisting of elements that satisfy p
    xs dropWhile p    // the remainder of the list after any leading element satisfying p have been removed
    xs span p         // same as (xs takeWhile p, xs dropWhile p)

    List(x1, ..., xn) reduceLeft op    // (...(x1 op x2) op x3) op ...) op xn
    List(x1, ..., xn).foldLeft(z)(op)  // (...( z op x1) op x2) op ...) op xn
    List(x1, ..., xn) reduceRight op   // x1 op (... (x{n-1} op xn) ...)
    List(x1, ..., xn).foldRight(z)(op) // x1 op (... (    xn op  z) ...)

    xs exists p    // true if there is at least one element for which predicate p is true
    xs forall p    // true if p(x) is true for all elements
    xs zip ys      // returns a list of pairs which groups elements with same index together
    xs unzip       // opposite of zip: returns a pair of two lists
    xs.flatMap f   // applies the function to all elements and concatenates the result
    xs.sum         // sum of elements of the numeric collection
    xs.product     // product of elements of the numeric collection
    xs.max         // maximum of collection
    xs.min         // minimum of collection
    xs.flatten     // flattens a collection of collection into a single-level collection
    xs groupBy f   // returns a map which points to a list of elements
    xs distinct    // sequence of distinct entries (removes duplicates)

    x +: xs  // creates a new collection with leading element x
    xs :+ x  // creates a new collection with trailing element x

    // Operations on maps
    val myMap = Map(&quot;I&quot; -&gt; 1, &quot;V&quot; -&gt; 5, &quot;X&quot; -&gt; 10)  // create a map
    myMap(&quot;I&quot;)      // =&gt; 1  
    myMap(&quot;A&quot;)      // =&gt; java.util.NoSuchElementException  
    myMap get &quot;A&quot;   // =&gt; None 
    myMap get &quot;I&quot;   // =&gt; Some(1)
    myMap.updated(&quot;V&quot;, 15)  // returns a new map where &quot;V&quot; maps to 15 (entry is updated)
                            // if the key (&quot;V&quot; here) does not exist, a new entry is added

    // Operations on Streams
    val xs = Stream(1, 2, 3)
    val xs = Stream.cons(1, Stream.cons(2, Stream.cons(3, Stream.empty))) // same as above
    (1 to 1000).toStream // =&gt; Stream(1, ?)
    x #:: xs // Same as Stream.cons(x, xs)
             // In the Stream's cons operator, the second parameter (the tail)
             // is defined as a &quot;call by name&quot; parameter.
             // Note that x::xs always produces a List
</code></pre>

<h3 id="pairs-similar-for-larger-tuples">Pairs (similar for larger Tuples)</h3>
<pre><code class="scala">    val pair = (&quot;answer&quot;, 42)   // type: (String, Int)
    val x = (&quot;x&quot; -&gt; 90)         // type: (String, Int)
    val y = (&quot;y&quot; -&gt; -5)         // type: (String, Int)
    val z = (&quot;z&quot; -&gt; 0)          // type: (String, Int)
    val (label, value) = pair   // label = &quot;answer&quot;, value = 42  
    pair._1 // &quot;answer&quot;  
    pair._2 // 42  
</code></pre>

<h2 id="ordering">Ordering</h2>
<p>There is already a class in the standard library that represents orderings: <code>scala.math.Ordering[T]</code> which contains
comparison functions such as <code>lt()</code> and <code>gt()</code> for standard types. Types with a single natural ordering should inherit from 
the trait <code>scala.math.Ordered[T]</code>.</p>
<pre><code class="scala">    import math.Ordering  

    def msort[T](xs: List[T])(implicit ord: Ordering) = { ...}  
    msort(fruits)(Ordering.String)  
    msort(fruits)   // the compiler figures out the right ordering  
</code></pre>

<h2 id="map-and-flatmap">map() and flatMap()</h2>
<p>To be added</p>
<h1 id="category-theory">Category Theory</h1>
<h2 id="algrebraic-data-type">Algrebraic Data Type</h2>
<h2 id="typeclass">Typeclass</h2>
<blockquote>
<p><em>[...] Type class is a class (group) of types, which satisfy some contract defined in a trait with addition that such functionality (trait and implementation) can be added without any changes to the original code. One could say that the same could be achieved by extending a simple trait, but with type classes it is not necessary to predict such a need beforehand.</em></p>
<p><em>There is no special syntax in Scala to express a type class, but the same functionality can be achieved using constructs that already exist in the language. <strong>That’s what makes it a little difficult for newcomers to spot a type class in code. A typical implementation of a type class uses some syntactic sugar as well, which also doesn’t make it clear right away what we are dealing with</strong>.</em></p>
</blockquote>
<p>https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html</p>
<p><strong>Type constructor and Variance</strong></p>
<p>pag. 392 of the White Scala Manual</p>
<h2 id="monoid">Monoid</h2>
<p>The Monoid is essentially the first purely <em>algebraic</em> data structures. The term <em>monoid</em> is taken from the <strong>Category Theory</strong>, and it means a category with one object. This kind of algebraic data structures are the corner stone of the technique that gives us the ability to write <strong>polymorphic functions</strong>. A Monoid is made of:</p>
<ul>
<li>A type <code>T</code></li>
<li>A binary operation, which is associative, that takes two values of type <code>T</code> and combines them into one</li>
<li>A value <code>zero: T</code> which is an <em>identity</em> for the associative operation</li>
</ul>
<pre><code class="scala">/**
  * It is defined by some type A, an associative binary operation that takes 
  */
trait Monoid[T] {
  // associativity
  // op(op(x, y), z) == op(x, op(y, z))
  def op(x: T, y: T): T

  // identity
  // op(x, zero) == op(zero, x) == x
  def zero: T
}

// example
val stringMonoid = new Monoid[String] {
  override def op(x: String, y: String): String = x + y
  override def zero: String = &quot;&quot;
}
</code></pre>

<h2 id="fold-foldright-and-foldleft">fold: foldRight() and foldLeft()</h2>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../links/" class="btn btn-neutral float-right" title="Links">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/sentenza/docs/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../links/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
