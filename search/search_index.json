{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About After a lot of thinking, following the example of @niqdev , I've decided to create this project to collect all the useful information about what I like most: programming . This is still a draft of what can be a useful source of inspiration for new and old developers, and I've chosen to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share the knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre. Why doing this? Most of all because writing good software is hard , and doing it without organizing your knowledge and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. Now the skillful workman is very careful indeed as to what he takes into his brain-attic . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887 Contributors A list of contributors to this project: @sentenza","title":"Home"},{"location":"#about","text":"After a lot of thinking, following the example of @niqdev , I've decided to create this project to collect all the useful information about what I like most: programming . This is still a draft of what can be a useful source of inspiration for new and old developers, and I've chosen to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share the knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre.","title":"About"},{"location":"#why-doing-this","text":"Most of all because writing good software is hard , and doing it without organizing your knowledge and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. Now the skillful workman is very careful indeed as to what he takes into his brain-attic . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887","title":"Why doing this?"},{"location":"#contributors","text":"A list of contributors to this project: @sentenza","title":"Contributors"},{"location":"links/","text":"Functional Programming (FP) Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming FP Papers Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky ) Scala Books Functional Programming, Simplified (2017) by Alvin Alexander ( companion of the Red Book ) Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason ( The Red Book ) Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless Readings Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples Cats and Shapeless Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk) Haskell and OCaml Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Links"},{"location":"links/#functional-programming-fp","text":"Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming","title":"Functional Programming (FP)"},{"location":"links/#fp-papers","text":"Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky )","title":"FP Papers"},{"location":"links/#scala","text":"Books Functional Programming, Simplified (2017) by Alvin Alexander ( companion of the Red Book ) Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason ( The Red Book ) Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless Readings Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples Cats and Shapeless Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk)","title":"Scala"},{"location":"links/#haskell-and-ocaml","text":"Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Haskell and OCaml"},{"location":"scala/","text":"Evaluation rules def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort(x: List[Double]) // call by value def square(x: => List[Double]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction(ds: Double*) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function) General object hierarchy: NOTE: All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void Type Parameters Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. class TypedClass[F](arg1: F) { ??? } new TypedClass[Int](1) new TypedClass(1) // the type is being inferred, i.e. determined based on the value arguments Conventionally the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It is possible to restrict the type being used, e.g. def func[T <: TopLevel](arg: T): T = { ... } // T must derive from TopLevel or be TopLevel def func[T >: Level1](arg: T): T = { ... } // T must be a supertype of Level1 def func[T >: Level1 <: Top Level](arg: T): T = { ... } Variance Given A <: B If C[A] <: C[B] , C is covariant If C[A] >: C[B] , C is contravariant Otherwise C is nonvariant class C[+A] { ... } // C is covariant class C[-A] { ... } // C is contravariant class C[A] { ... } // C is nonvariant For a function, if A2 <: A1 and B1 <: B2 , then A1 => B1 <: A2 => B2 . Functions must be contravariant in their argument types and covariant in their result types , e.g. trait Function1[-T, +U] { def apply(x: T): U } // Variance check is OK because T is contravariant and U is covariant class Array[+T] { def update(x: T) } // variance checks fails Find out more about variance in Covariance And Contravariance in Scala","title":"Scala"},{"location":"scala/#evaluation-rules","text":"def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort(x: List[Double]) // call by value def square(x: => List[Double]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction(ds: Double*) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function)","title":"Evaluation rules"},{"location":"scala/#general-object-hierarchy","text":"NOTE: All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void","title":"General object hierarchy:"},{"location":"scala/#type-parameters","text":"Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. class TypedClass[F](arg1: F) { ??? } new TypedClass[Int](1) new TypedClass(1) // the type is being inferred, i.e. determined based on the value arguments Conventionally the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It is possible to restrict the type being used, e.g. def func[T <: TopLevel](arg: T): T = { ... } // T must derive from TopLevel or be TopLevel def func[T >: Level1](arg: T): T = { ... } // T must be a supertype of Level1 def func[T >: Level1 <: Top Level](arg: T): T = { ... }","title":"Type Parameters"},{"location":"scala/#variance","text":"Given A <: B If C[A] <: C[B] , C is covariant If C[A] >: C[B] , C is contravariant Otherwise C is nonvariant class C[+A] { ... } // C is covariant class C[-A] { ... } // C is contravariant class C[A] { ... } // C is nonvariant For a function, if A2 <: A1 and B1 <: B2 , then A1 => B1 <: A2 => B2 . Functions must be contravariant in their argument types and covariant in their result types , e.g. trait Function1[-T, +U] { def apply(x: T): U } // Variance check is OK because T is contravariant and U is covariant class Array[+T] { def update(x: T) } // variance checks fails Find out more about variance in Covariance And Contravariance in Scala","title":"Variance"}]}