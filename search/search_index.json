{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About After a lot of thinking, following the example of @niqdev , I made up my mind to create this project to collect all the useful information about what I like most: programming . This is still a collection of what I think might be useful resources for inspiring new and old developers. I chose to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre. Why doing this? Most of all because writing good software is hard , and doing it without organizing and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: Quote \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. Now the skillful workman is very careful indeed as to what he takes into his brain-attic . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887 Contributors @sentenza","title":"Home"},{"location":"#about","text":"After a lot of thinking, following the example of @niqdev , I made up my mind to create this project to collect all the useful information about what I like most: programming . This is still a collection of what I think might be useful resources for inspiring new and old developers. I chose to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre.","title":"About"},{"location":"#why-doing-this","text":"Most of all because writing good software is hard , and doing it without organizing and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: Quote \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. Now the skillful workman is very careful indeed as to what he takes into his brain-attic . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887","title":"Why doing this?"},{"location":"#contributors","text":"@sentenza","title":"Contributors"},{"location":"kubernetes/","text":"So Kubernetes is pronounced /koo-ber-nay'-tace/ and means \"sailing master\" Via @francesc Terminology Node : A single virtual or physical machine in a Kubernetes cluster. Cluster: A group of nodes firewalled from the internet, that are the primary compute resources managed by Kubernetes. Edge router: A router that enforces the firewall policy for your cluster. This could be a gateway managed by a cloud provider or a physical piece of hardware. Cluster network: A set of links, logical or physical, that facilitate communication within a cluster according to the Kubernetes networking model . Examples of a Cluster network include Overlays such as flannel or SDNs such as OVS. Service: A Kubernetes Service that identifies a set of pods using label selectors. Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network. What is a pod?? A pod is a group of one or more containers (such as Docker containers), with shared storage/network, and a specification for how to run the containers. A pod\u2019s contents are always co-located and co-scheduled, and run in a shared context. Containers within a pod share an IP address and port space, and can find each other via localhost. They can also communicate with each other using standard inter-process communications like SystemV semaphores or POSIX shared memory. Containers in different pods have distinct IP addresses and can not communicate by IPC without special configuration. These containers usually communicate with each other via Pod IP addresses. In terms of Docker constructs, a pod is modelled as a group of Docker containers with shared namespaces and shared volumes . Kubernetes \"plugins\" Helm Tiller : Helm is a package manager for Kubernetes and is required to install all the other applications. It is installed in its own pod inside the cluster which can run the helm CLI in a safe environment. Ingress : Ingress can provide load balancing, SSL termination, and name-based virtual hosting. It acts as a web proxy for your applications and is useful if you want to use Auto DevOps or deploy your own web apps. Prometheus : Prometheus is an open-source monitoring and alerting system useful to supervise your deployed applications. How to manage the Google Kubernetes Engine The first step is to check the defined clusters [using the Google Cloud Platform console][gcp-console]. The most common target is, at first, to build and push a containarised application, which means that we start creating a new docker image in our machine, then after checking it locally, we push the image to a docker container registry . Using GCP all these operations can be done by using a mix of docker , gcloud and kubectl commands. First things first, we must create one or more images using the instructions provided here . After that, one can follow the instructions of this gcloud tutorial . Setting a static IP and a custom domain for the application In our case we can assign a static IP address for the service created one step above. The best way to achieve this, IMHO, is the web interface and precisely here . Update the image used for the current Kubernetes POD Build a new snapshot optimized for production ng build --prod Create a new image and tag it with a new version Test the new image locally Push the newly created image to the container registry To update the deployed container we can use the set command: kubectl set image deployment/together-rx ... Problem: A frequent question that comes up on Slack and Stack Overflow is how to trigger an update to a Deployment/RS/RC when the image tag hasn't changed but the underlying image has. Consider: There is an existing Deployment with image foo : latest User builds a new image foo : latest User pushes foo : latest to their registry User wants to do something here to tell the Deployment to pull the new image and do a rolling-update of existing pods Possible solution for our current scenario: you are using latest for testing (this is the \"no sed\" use case), in this case, downtime is fine, and indeed the right approach is likely to completely blow away your stack and redeploy from scratch to get a clean run (= kubectl set ... ). Keep reading here . Delete a Kubernetes service To stop and delete a Kubernetes instance/service corresponding to the image we created and then exposed we should instruct Kubernetes to tell the Load Balancer to delete the provisioned service with a simple command like that: kubectl delete service container-1 NOTE: The load balancer is deleted asynchronously in the background when you run kubectl delete . Wait until the load balancer is deleted by watching the output of the following command: gcloud compute forwarding-rules list Storage and DBs on GKE High Availability PostgreSQL and Kubernetes with Google Cloud How to pronounce Kubernetes","title":"Kubernetes"},{"location":"kubernetes/#terminology","text":"Node : A single virtual or physical machine in a Kubernetes cluster. Cluster: A group of nodes firewalled from the internet, that are the primary compute resources managed by Kubernetes. Edge router: A router that enforces the firewall policy for your cluster. This could be a gateway managed by a cloud provider or a physical piece of hardware. Cluster network: A set of links, logical or physical, that facilitate communication within a cluster according to the Kubernetes networking model . Examples of a Cluster network include Overlays such as flannel or SDNs such as OVS. Service: A Kubernetes Service that identifies a set of pods using label selectors. Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network.","title":"Terminology"},{"location":"kubernetes/#what-is-a-pod","text":"A pod is a group of one or more containers (such as Docker containers), with shared storage/network, and a specification for how to run the containers. A pod\u2019s contents are always co-located and co-scheduled, and run in a shared context. Containers within a pod share an IP address and port space, and can find each other via localhost. They can also communicate with each other using standard inter-process communications like SystemV semaphores or POSIX shared memory. Containers in different pods have distinct IP addresses and can not communicate by IPC without special configuration. These containers usually communicate with each other via Pod IP addresses. In terms of Docker constructs, a pod is modelled as a group of Docker containers with shared namespaces and shared volumes .","title":"What is a pod??"},{"location":"kubernetes/#kubernetes-plugins","text":"Helm Tiller : Helm is a package manager for Kubernetes and is required to install all the other applications. It is installed in its own pod inside the cluster which can run the helm CLI in a safe environment. Ingress : Ingress can provide load balancing, SSL termination, and name-based virtual hosting. It acts as a web proxy for your applications and is useful if you want to use Auto DevOps or deploy your own web apps. Prometheus : Prometheus is an open-source monitoring and alerting system useful to supervise your deployed applications.","title":"Kubernetes \"plugins\""},{"location":"kubernetes/#how-to-manage-the-google-kubernetes-engine","text":"The first step is to check the defined clusters [using the Google Cloud Platform console][gcp-console]. The most common target is, at first, to build and push a containarised application, which means that we start creating a new docker image in our machine, then after checking it locally, we push the image to a docker container registry . Using GCP all these operations can be done by using a mix of docker , gcloud and kubectl commands. First things first, we must create one or more images using the instructions provided here . After that, one can follow the instructions of this gcloud tutorial .","title":"How to manage the Google Kubernetes Engine"},{"location":"kubernetes/#setting-a-static-ip-and-a-custom-domain-for-the-application","text":"In our case we can assign a static IP address for the service created one step above. The best way to achieve this, IMHO, is the web interface and precisely here .","title":"Setting a static IP and a custom domain for the application"},{"location":"kubernetes/#update-the-image-used-for-the-current-kubernetes-pod","text":"Build a new snapshot optimized for production ng build --prod Create a new image and tag it with a new version Test the new image locally Push the newly created image to the container registry To update the deployed container we can use the set command: kubectl set image deployment/together-rx ... Problem: A frequent question that comes up on Slack and Stack Overflow is how to trigger an update to a Deployment/RS/RC when the image tag hasn't changed but the underlying image has. Consider: There is an existing Deployment with image foo : latest User builds a new image foo : latest User pushes foo : latest to their registry User wants to do something here to tell the Deployment to pull the new image and do a rolling-update of existing pods Possible solution for our current scenario: you are using latest for testing (this is the \"no sed\" use case), in this case, downtime is fine, and indeed the right approach is likely to completely blow away your stack and redeploy from scratch to get a clean run (= kubectl set ... ). Keep reading here .","title":"Update the image used for the current Kubernetes POD"},{"location":"kubernetes/#delete-a-kubernetes-service","text":"To stop and delete a Kubernetes instance/service corresponding to the image we created and then exposed we should instruct Kubernetes to tell the Load Balancer to delete the provisioned service with a simple command like that: kubectl delete service container-1 NOTE: The load balancer is deleted asynchronously in the background when you run kubectl delete . Wait until the load balancer is deleted by watching the output of the following command: gcloud compute forwarding-rules list","title":"Delete a Kubernetes service"},{"location":"kubernetes/#storage-and-dbs-on-gke","text":"High Availability PostgreSQL and Kubernetes with Google Cloud How to pronounce Kubernetes","title":"Storage and DBs on GKE"},{"location":"links/","text":"Links and external resources Functional Programming Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming FP Papers Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky ) Scala Books Programming in Scala (2016) by Martin Odersky, Lex Spoon, and Bill Venners Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason (*The Red Book* ) A companion booklet to \"Functional Programming in Scala\" (PDF) by R\u00fanar \u00d3li Bjarnason Functional Programming, Simplified (2017) by Alvin Alexander Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless Readings Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples Cats and Shapeless Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk) Haskell and OCaml Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Links"},{"location":"links/#links-and-external-resources","text":"","title":"Links and external resources"},{"location":"links/#functional-programming","text":"Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming","title":"Functional Programming"},{"location":"links/#fp-papers","text":"Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky )","title":"FP Papers"},{"location":"links/#scala","text":"","title":"Scala"},{"location":"links/#books","text":"Programming in Scala (2016) by Martin Odersky, Lex Spoon, and Bill Venners Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason (*The Red Book* ) A companion booklet to \"Functional Programming in Scala\" (PDF) by R\u00fanar \u00d3li Bjarnason Functional Programming, Simplified (2017) by Alvin Alexander Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless","title":"Books"},{"location":"links/#readings","text":"Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples","title":"Readings"},{"location":"links/#cats-and-shapeless","text":"Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk)","title":"Cats and Shapeless"},{"location":"links/#haskell-and-ocaml","text":"Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Haskell and OCaml"},{"location":"scala/","text":"Scala Evaluation rules def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters 1 2 3 4 5 6 7 8 def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort ( x : List [ Double ]) // call by value def sort ( x : = List [ Double ]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction ( ds : Double* ) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function) Type Parameters Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. 1 2 3 class TypedClass [ F ]( arg1 : F ) { ??? } new TypedClass [ Int ]( 1 ) new TypedClass ( 1 ) // the type is being inferred, i.e. determined based on the value arguments Conventionally, the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It's also possible to restrict the type being used, e.g. 1 2 3 def func [ T : TopLevel ]( arg : T ) : T = { ... } // T must derive from TopLevel or be TopLevel def func [ T : Level1 ]( arg : T ) : T = { ... } // T must be a supertype of Level1 def func [ T : Level1 : Top Level ]( arg : T ) : T = { ... } Variance Quote Variance being a tricky business, users usually get it wrong , and they come away thinking that wildcard and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available. - Programming in Scala Upper Bounds: [S : T] means: S is a subtype of T. Let's suppose that T is actually an Iterable , then S could one of Seq , List or Iterable . Lower Bounds: [S : T] means: S is a supertype of T, or T is a subtype of S. So, if T is a List , S could be one of List , Seq , Iterable , or AnyRef . Mixed Bounds: [S : T2 : T1] means: s is any type on interval between T1 and T2. In this case we have basically a mix of the two cases above. Let's consider NonEmpty : IntSet , then can we infer that List[NonEmpty] : List[IntSet] ? Intuitively, this makes sense: a list of non-empty sets is a special case of a list of arbitrary sets. We call types for which this relationship holds covariant because their subtyping relationship varies with the type parameter. Thus Lists in scala are covariant . Does covariance make sense for all types, not just for List? No. For instance, in Scala, arrays are not covariant . When does it make sense to subtype one type with another? It is safe to assume that a type T is a subtype of a type U ( T : U ) if you can substitute a value of type T wherever a value of type U is required. This is called the Liskov Substitution Principle . Liskov Substitution Principle https://twitter.com/javi/status/1004821965868109824 Say C[T] is a parameterized type, and A, B are types such that: Given A : B (A is a subtype of B) If C[A] : C[B] , C is covariant If C[A] : C[B] , C is contravariant Neither C[A] or C[B] is a subtype of the other, then C is invariant (or \"nonvariant\" ). Scala lets you declare the variance of a type by annotating the type parameter: 1 2 3 class C [ +A ] { ... } // C is covariant class C [ -A ] { ... } // C is contravariant class C [ A ] { ... } // C is invariant So, given that Any AnyRef IntSet Empty and NonEmpty , if 1 2 type A = IntSet = NonEmpty type B = NonEmpty = IntSet According to the Liskov Principle = A : B , since B can return an Empty or NonEmpty, but A can return only NonEmpty. For a function, if A2 : A1 and B1 : B2 , then A1 = B1 : A2 = B2 . The consequence is that functions must be contravariant in their argument types and covariant in their result types . 1 2 3 4 5 /** The Scala Function1 S = T */ trait Function1 [ -S , +T ] { // S is contravariant, while T is covariant def apply ( x : S ) : T } This example shows that functions are contravariant in argument types and covariant in return types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package io.github.sentenza.cars class Car {} class SportsCar extends Car {} class Ferrari extends SportsCar {} object morecovariance extends App { // Test 1: Works as expected def test1 ( arg : SportsCar = SportsCar ) = { new SportsCar } def foo1 ( arg : Car ) : Ferrari = { new Ferrari } def foo2 ( arg : SportsCar ) : Car = { new Ferrari } def foo3 ( arg : Ferrari ) : Ferrari = { new Ferrari } test1 ( foo1 ) // compiles test1 ( foo2 ) // Fails due to wrong return type. test1 ( foo3 ) // Fails due to wrong parameter type } Find out more about variance in Covariance And Contravariance in Scala Type constructor and Variance Abstract To be added pag. 392 of the White Scala Manual Objects and Code organization Quote Scala has no globally visible methods: every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods. From Programming in Scala - Second edition (by M. Odersky, L. Spoon, B. Venners) As you can read above, I introduced Objects in terms of the functions they contain . It's very important to stress on this aspect, because Classes and Objects should be seen under a different light using Scala, especially if you come from an imperative OOP language, like Java or C++. They are just a way to organise your functions and at some point, using traits, objects (companion objects) and case classes (data constructors) you will eventually be able to build up your coding architecture based on types and composition of functions. General object hierarchy Note All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void Factory Object The following example has been taken from Programming in Scala : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract class Element { def contents : Array [ String ] def height : Int = contents . length def width : Int = if ( height == 0 ) 0 else contents ( 0 ). length } class ArrayElements ( val contents : Array [ String ]) extends Element // Invoking superclass constructor while extending the class itself class LineElement ( s : String ) extends ArrayElement ( Array ( s )) { override def width = s . length // Int is inferred override def width = 1 } class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } Now, what we can do is defining a Factory Object which contains methods that construct other objects, without exposing each class implementation. Basically, we can hide each class inside a Singleton Object, which will represent just a tag for the overloaded methods that will give us the ability to instantiate each subclass dinamically, and using polymorphism at the same time. Important Note that OOP is not a paradigm, but it's just a way to define our code structure in a logic manner that is similar to playing with LEGOs. OOP can be seen like an orthogonal dimension compared to functional, declarative or imperative paradigms. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // We start defining a Singleton Object object Element { // we can now hide classes as private fields of this object private class ArrayElements ( val contents : Array [ String ] ) extends Element private class LineElement ( s : String ) extends Element { val contents = Array ( s ) override def width = s . length override def width = 1 } private class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } // FACTORY def elem ( contents : Array [ String ]) : Element = new ArrayElement ( contents ) def elem ( chr : Char , width : Int , heigth : Int ) : Element = new UniformElement ( chr , width , height ) def elem ( line : String ) : Elem = new LineElement ( line ) } Objects creation are centralized and the details now are hidden. Open/Closed Principle This will eventually give an easy way to understand how to use these elements, and at the same time this small change will give the developer the Open/Closed Principle for free because less detail is exposed. \u201cSoftware entities \u2026 should be open for extension, but closed for modification.\u201d This provides more opportunities to change the implementation of the library without breaking client code . At the same time a class will have a single responsibility, and only one potential change in the software\u2019s specification should be able to affect the specification of the class ( Single Responsibility Principle ). So, writing SOLID code pays off at the end. Factory method In Java you can create a private constructor by making it private . In Scala one can achieve the same behaviour prepending the private modifier to the default constructor. 1 2 3 4 5 6 7 8 9 10 11 12 class Point private ( coordX : Float , coordY : Float ) { val x = coordX val y = coordY /** Public auxiliary constructor * Setting the point at the origin of the Cartesian axes * calling the default private constructor using the */ def this () = this ( 0.0 , 0.0 ) def getPoint = ( x , y ) } You cannot instantiate a new point using the default constructor: 1 2 val errorPoint = new Point ( 45.9 , 21.08 ) // ERROR val correctPoint = new Point () // (0.0, 0.0) A possible solution to define a new Point is given by the usage of a companion object and a factory method that will give us a convenient way to define a new object, without actually call the new operator. To do so one can add the apply() method to the newly created object, which will have the same acess rights to the Point class if placed in the same file. Therefore, the apply() method will be able to use the private construction of the Point class and then it will become a factory method : 1 2 3 4 class Point [ T : Double ] private ( coordX : T , coordY : T ) { ... } object Point { def apply [ T : Double ]( x : T , y : T ) = new Point [ T ]( x , y ) } Collections Scala defines several collection classes: Base Classes Iterable (collections you can iterate on) Seq (ordered sequences) Set Map (lookup data structure) Immutable Collections List (linked list, provides fast sequential access) Stream (same as List, except that the tail is evaluated only on demand) Vector (array-like type, implemented as tree of blocks, provides fast random access) Range (ordered sequence of integers with equal spacing) String (Java type, implicitly converted to a character sequence, so you can treat every string like a Seq[Char] ) Map (collection that maps keys to values) Set (collection without duplicate elements) Mutable Collections Array (Scala arrays are native JVM arrays at runtime, therefore they are very performant) Scala also has mutable maps and sets; these should only be used if there are performance issues with immutable types Collections snippet Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 val r : Range = 1 until 5 // 1, 2, 3, 4 val s : Range = 1 to 5 // 1, 2, 3, 4, 5 1 to 10 by 3 // 1, 4, 7, 10 6 to 1 by - 2 // 6, 4, 2 // Operations on sequences val xs = List (...) xs . length // number of elements, complexity O(n) xs . last // last element (exception if xs is empty), complexity O(n) xs . init // all elements of xs but the last (exception if xs is empty), complexity O(n) xs take n // first n elements of xs xs drop n // the rest of the collection after taking n elements xs ( n ) // the nth element of xs, complexity O(n) xs ++ ys // concatenation, complexity O(n) xs . reverse // reverse the order, complexity O(n) xs updated ( n , x ) // same list than xs, except at index n where it contains x, complexity O(n) xs indexOf x // the index of the first element equal to x (-1 otherwise) xs contains x // same as xs indexOf x = 0 xs filter p // returns a list of the elements that satisfy the predicate p xs filterNot p // filter with negated p xs partition p // same as (xs filter p, xs filterNot p) xs takeWhile p // the longest prefix consisting of elements that satisfy p xs dropWhile p // the remainder of the list after any leading element satisfying p have been removed xs span p // same as (xs takeWhile p, xs dropWhile p) List ( x1 , ..., xn ) reduceLeft op // (...(x1 op x2) op x3) op ...) op xn List ( x1 , ..., xn ). foldLeft ( z )( op ) // (...( z op x1) op x2) op ...) op xn List ( x1 , ..., xn ) reduceRight op // x1 op (... (x{n-1} op xn) ...) List ( x1 , ..., xn ). foldRight ( z )( op ) // x1 op (... ( xn op z) ...) xs exists p // true if there is at least one element for which predicate p is true xs forall p // true if p(x) is true for all elements xs zip ys // returns a list of pairs which groups elements with same index together xs unzip // opposite of zip: returns a pair of two lists xs . flatMap f // applies the function to all elements and concatenates the result xs . sum // sum of elements of the numeric collection xs . product // product of elements of the numeric collection xs . max // maximum of collection xs . min // minimum of collection xs . flatten // flattens a collection of collection into a single-level collection xs groupBy f // returns a map which points to a list of elements xs distinct // sequence of distinct entries (removes duplicates) x +: xs // creates a new collection with leading element x xs :+ x // creates a new collection with trailing element x // Operations on maps val myMap = Map ( I - 1 , V - 5 , X - 10 ) // create a map myMap ( I ) // = 1 myMap ( A ) // = java.util.NoSuchElementException myMap get A // = None myMap get I // = Some(1) myMap . updated ( V , 15 ) // returns a new map where V maps to 15 (entry is updated) // if the key ( V here) does not exist, a new entry is added // Operations on Streams val xs = Stream ( 1 , 2 , 3 ) val xs = Stream . cons ( 1 , Stream . cons ( 2 , Stream . cons ( 3 , Stream . empty ))) // same as above ( 1 to 1000 ). toStream // = Stream(1, ?) x #:: xs // Same as Stream.cons(x, xs) // In the Stream s cons operator, the second parameter (the tail) // is defined as a call by name parameter. // Note that x::xs always produces a List Pairs (similar for larger Tuples) 1 2 3 4 5 6 7 val pair = ( answer , 42 ) // type: (String, Int) val x = ( x - 90 ) // type: (String, Int) val y = ( y - - 5 ) // type: (String, Int) val z = ( z - 0 ) // type: (String, Int) val ( label , value ) = pair // label = answer , value = 42 pair . _1 // answer pair . _2 // 42 Ordering There is already a class in the standard library that represents orderings: scala.math.Ordering[T] which contains comparison functions such as lt() and gt() for standard types. Types with a single natural ordering should inherit from the trait scala.math.Ordered[T] . 1 2 3 4 5 import math.Ordering def msort [ T ]( xs : List [ T ])( implicit ord : Ordering ) = { ...} msort ( fruits )( Ordering . String ) msort ( fruits ) // the compiler figures out the right ordering map() and flatMap() Abstract To be added Category Theory Abstract To be added Algrebraic Data Type Abstract To be added Typeclass Quote [...] Type class is a class (group) of types, which satisfy some contract defined in a trait with addition that such functionality (trait and implementation) can be added without any changes to the original code. One could say that the same could be achieved by extending a simple trait, but with type classes it is not necessary to predict such a need beforehand. There is no special syntax in Scala to express a type class, but the same functionality can be achieved using constructs that already exist in the language. That\u2019s what makes it a little difficult for newcomers to spot a type class in code. A typical implementation of a type class uses some syntactic sugar as well, which also doesn\u2019t make it clear right away what we are dealing with . https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html Monoid The Monoid is essentially the first purely algebraic data structures. The term monoid is taken from the Category Theory , and it means a category with one object. This kind of algebraic data structures are the corner stone of the technique that gives us the ability to write polymorphic functions . A Monoid is made of: A type T A binary operation, which is associative, that takes two values of type T and combines them into one A value zero : T which is an identity for the associative operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * It is defined by some type A, an associative binary operation that takes */ trait Monoid [ T ] { // associativity // op(op(x, y), z) == op(x, op(y, z)) def op ( x : T , y : T ) : T // identity // op(x, zero) == op(zero, x) == x def zero : T } // example val stringMonoid = new Monoid [ String ] { override def op ( x : String , y : String ) : String = x + y override def zero : String = } fold: foldRight() and foldLeft() Abstract To be added SBT Defining dependencies and Settins in /project Functor A Functor is just a type constructor for which map can be implemented: 1 2 3 trait Functor [ F [ _ ]] { def map [ T , R ]( fa : F [ T ])( f : T = R ) : F [ R ] } Monad Monads are like wrappers that provide us with two fundamental operations: identity (that we refer as unit in Scala - or pure ) bind ( flatMap in Scala) Monads in Category Theory In Category Theory, a Monad is a Functor equipped with a pair of \"natural transformations\" satisfying the laws of associativity and identity. And then a question arises spontaneously: how should I describe a Monad in Scala? 1 2 3 4 5 trait M [ T ] { def flatMap [ T ]( f : T = M [ R ]) : M [ R ] } def unit [ T ]( x : T ) : M [ T ] As you might have supposed unit[MyType](x) performs the wrapping into a Monad[MyType] . It's pretty clear that we defined the method unit() outside the trait body because we don\u2019t want to invoke it upon the existing monadic object. Monad laws If we have some basic value x , a monad instance m (holding some value) and functions f and g of type Int \u2192 M[Int] , we can write the laws as follows: left-identity law : 1 unit ( x ). flatMap ( f ) == f ( x ) right-identity law : 1 m . flatMap ( unit ) == m associativity law : 1 m . flatMap ( f ). flatMap ( g ) == m . flatMap ( x \u21d2 f ( x ). flatMap ( g )) On flatMap 1 2 map with T = M[R] flatten M[T] ------------------------- M[M[R]] ----------- M[R] Why do we need monads? Functions should (to be simpler) return only one thing . Solution: let's create a new type of data to be returned, a \" boxing type \" that encloses maybe a real or be simply nothing. Hence, we can have g: (x: Real, y: Real) = Option[Real] . OK, but\u2026 What happens now to f(g(x,y)) ? f is not ready to consume an Option[Real] . And, we don't want to change every function we could connect with g to consume an Option[Real] . Solution: let's have a special function to \"connect\"/\"compose\"/\"link\" functions . That way, we can, behind the scenes, adapt the output of one function to feed the following one. In our case: g.flatMap(f) (connect/compose g to f ). We want flatMap to get g 's output, inspect it and, in case it is None just don't call f and return None ; or on the contrary, extract the boxed Real and feed f with it. Many other problems arise which can be solved using this same pattern: 1. Use a \"box\" to codify/store different meanings/values, and have functions like g that return those \"boxed values\". Have composers/linkers g flatMap f to help connecting g 's output to f 's input, so we don't have to change f at all. Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions (\"the program\") can share: solution StateMonad . We don't like \"impure functions\": functions that yield different output for same input. Therefore, let's mark those functions, making them to return a tagged/boxed value: IO monad. https://stackoverflow.com/a/28135478/1977778 About Monads","title":"Scala"},{"location":"scala/#scala","text":"","title":"Scala"},{"location":"scala/#evaluation-rules","text":"def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters 1 2 3 4 5 6 7 8 def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort ( x : List [ Double ]) // call by value def sort ( x : = List [ Double ]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction ( ds : Double* ) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function)","title":"Evaluation rules"},{"location":"scala/#type-parameters","text":"Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. 1 2 3 class TypedClass [ F ]( arg1 : F ) { ??? } new TypedClass [ Int ]( 1 ) new TypedClass ( 1 ) // the type is being inferred, i.e. determined based on the value arguments Conventionally, the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It's also possible to restrict the type being used, e.g. 1 2 3 def func [ T : TopLevel ]( arg : T ) : T = { ... } // T must derive from TopLevel or be TopLevel def func [ T : Level1 ]( arg : T ) : T = { ... } // T must be a supertype of Level1 def func [ T : Level1 : Top Level ]( arg : T ) : T = { ... }","title":"Type Parameters"},{"location":"scala/#variance","text":"Quote Variance being a tricky business, users usually get it wrong , and they come away thinking that wildcard and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available. - Programming in Scala Upper Bounds: [S : T] means: S is a subtype of T. Let's suppose that T is actually an Iterable , then S could one of Seq , List or Iterable . Lower Bounds: [S : T] means: S is a supertype of T, or T is a subtype of S. So, if T is a List , S could be one of List , Seq , Iterable , or AnyRef . Mixed Bounds: [S : T2 : T1] means: s is any type on interval between T1 and T2. In this case we have basically a mix of the two cases above. Let's consider NonEmpty : IntSet , then can we infer that List[NonEmpty] : List[IntSet] ? Intuitively, this makes sense: a list of non-empty sets is a special case of a list of arbitrary sets. We call types for which this relationship holds covariant because their subtyping relationship varies with the type parameter. Thus Lists in scala are covariant . Does covariance make sense for all types, not just for List? No. For instance, in Scala, arrays are not covariant . When does it make sense to subtype one type with another? It is safe to assume that a type T is a subtype of a type U ( T : U ) if you can substitute a value of type T wherever a value of type U is required. This is called the Liskov Substitution Principle . Liskov Substitution Principle https://twitter.com/javi/status/1004821965868109824 Say C[T] is a parameterized type, and A, B are types such that: Given A : B (A is a subtype of B) If C[A] : C[B] , C is covariant If C[A] : C[B] , C is contravariant Neither C[A] or C[B] is a subtype of the other, then C is invariant (or \"nonvariant\" ). Scala lets you declare the variance of a type by annotating the type parameter: 1 2 3 class C [ +A ] { ... } // C is covariant class C [ -A ] { ... } // C is contravariant class C [ A ] { ... } // C is invariant So, given that Any AnyRef IntSet Empty and NonEmpty , if 1 2 type A = IntSet = NonEmpty type B = NonEmpty = IntSet According to the Liskov Principle = A : B , since B can return an Empty or NonEmpty, but A can return only NonEmpty. For a function, if A2 : A1 and B1 : B2 , then A1 = B1 : A2 = B2 . The consequence is that functions must be contravariant in their argument types and covariant in their result types . 1 2 3 4 5 /** The Scala Function1 S = T */ trait Function1 [ -S , +T ] { // S is contravariant, while T is covariant def apply ( x : S ) : T } This example shows that functions are contravariant in argument types and covariant in return types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package io.github.sentenza.cars class Car {} class SportsCar extends Car {} class Ferrari extends SportsCar {} object morecovariance extends App { // Test 1: Works as expected def test1 ( arg : SportsCar = SportsCar ) = { new SportsCar } def foo1 ( arg : Car ) : Ferrari = { new Ferrari } def foo2 ( arg : SportsCar ) : Car = { new Ferrari } def foo3 ( arg : Ferrari ) : Ferrari = { new Ferrari } test1 ( foo1 ) // compiles test1 ( foo2 ) // Fails due to wrong return type. test1 ( foo3 ) // Fails due to wrong parameter type } Find out more about variance in Covariance And Contravariance in Scala Type constructor and Variance Abstract To be added pag. 392 of the White Scala Manual","title":"Variance"},{"location":"scala/#objects-and-code-organization","text":"Quote Scala has no globally visible methods: every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods. From Programming in Scala - Second edition (by M. Odersky, L. Spoon, B. Venners) As you can read above, I introduced Objects in terms of the functions they contain . It's very important to stress on this aspect, because Classes and Objects should be seen under a different light using Scala, especially if you come from an imperative OOP language, like Java or C++. They are just a way to organise your functions and at some point, using traits, objects (companion objects) and case classes (data constructors) you will eventually be able to build up your coding architecture based on types and composition of functions.","title":"Objects and Code organization"},{"location":"scala/#general-object-hierarchy","text":"Note All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void","title":"General object hierarchy"},{"location":"scala/#factory-object","text":"The following example has been taken from Programming in Scala : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract class Element { def contents : Array [ String ] def height : Int = contents . length def width : Int = if ( height == 0 ) 0 else contents ( 0 ). length } class ArrayElements ( val contents : Array [ String ]) extends Element // Invoking superclass constructor while extending the class itself class LineElement ( s : String ) extends ArrayElement ( Array ( s )) { override def width = s . length // Int is inferred override def width = 1 } class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } Now, what we can do is defining a Factory Object which contains methods that construct other objects, without exposing each class implementation. Basically, we can hide each class inside a Singleton Object, which will represent just a tag for the overloaded methods that will give us the ability to instantiate each subclass dinamically, and using polymorphism at the same time. Important Note that OOP is not a paradigm, but it's just a way to define our code structure in a logic manner that is similar to playing with LEGOs. OOP can be seen like an orthogonal dimension compared to functional, declarative or imperative paradigms. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // We start defining a Singleton Object object Element { // we can now hide classes as private fields of this object private class ArrayElements ( val contents : Array [ String ] ) extends Element private class LineElement ( s : String ) extends Element { val contents = Array ( s ) override def width = s . length override def width = 1 } private class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } // FACTORY def elem ( contents : Array [ String ]) : Element = new ArrayElement ( contents ) def elem ( chr : Char , width : Int , heigth : Int ) : Element = new UniformElement ( chr , width , height ) def elem ( line : String ) : Elem = new LineElement ( line ) } Objects creation are centralized and the details now are hidden. Open/Closed Principle This will eventually give an easy way to understand how to use these elements, and at the same time this small change will give the developer the Open/Closed Principle for free because less detail is exposed. \u201cSoftware entities \u2026 should be open for extension, but closed for modification.\u201d This provides more opportunities to change the implementation of the library without breaking client code . At the same time a class will have a single responsibility, and only one potential change in the software\u2019s specification should be able to affect the specification of the class ( Single Responsibility Principle ). So, writing SOLID code pays off at the end.","title":"Factory Object"},{"location":"scala/#factory-method","text":"In Java you can create a private constructor by making it private . In Scala one can achieve the same behaviour prepending the private modifier to the default constructor. 1 2 3 4 5 6 7 8 9 10 11 12 class Point private ( coordX : Float , coordY : Float ) { val x = coordX val y = coordY /** Public auxiliary constructor * Setting the point at the origin of the Cartesian axes * calling the default private constructor using the */ def this () = this ( 0.0 , 0.0 ) def getPoint = ( x , y ) } You cannot instantiate a new point using the default constructor: 1 2 val errorPoint = new Point ( 45.9 , 21.08 ) // ERROR val correctPoint = new Point () // (0.0, 0.0) A possible solution to define a new Point is given by the usage of a companion object and a factory method that will give us a convenient way to define a new object, without actually call the new operator. To do so one can add the apply() method to the newly created object, which will have the same acess rights to the Point class if placed in the same file. Therefore, the apply() method will be able to use the private construction of the Point class and then it will become a factory method : 1 2 3 4 class Point [ T : Double ] private ( coordX : T , coordY : T ) { ... } object Point { def apply [ T : Double ]( x : T , y : T ) = new Point [ T ]( x , y ) }","title":"Factory method"},{"location":"scala/#collections","text":"Scala defines several collection classes:","title":"Collections"},{"location":"scala/#base-classes","text":"Iterable (collections you can iterate on) Seq (ordered sequences) Set Map (lookup data structure)","title":"Base Classes"},{"location":"scala/#immutable-collections","text":"List (linked list, provides fast sequential access) Stream (same as List, except that the tail is evaluated only on demand) Vector (array-like type, implemented as tree of blocks, provides fast random access) Range (ordered sequence of integers with equal spacing) String (Java type, implicitly converted to a character sequence, so you can treat every string like a Seq[Char] ) Map (collection that maps keys to values) Set (collection without duplicate elements)","title":"Immutable Collections"},{"location":"scala/#mutable-collections","text":"Array (Scala arrays are native JVM arrays at runtime, therefore they are very performant) Scala also has mutable maps and sets; these should only be used if there are performance issues with immutable types","title":"Mutable Collections"},{"location":"scala/#collections-snippet","text":"Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 val r : Range = 1 until 5 // 1, 2, 3, 4 val s : Range = 1 to 5 // 1, 2, 3, 4, 5 1 to 10 by 3 // 1, 4, 7, 10 6 to 1 by - 2 // 6, 4, 2 // Operations on sequences val xs = List (...) xs . length // number of elements, complexity O(n) xs . last // last element (exception if xs is empty), complexity O(n) xs . init // all elements of xs but the last (exception if xs is empty), complexity O(n) xs take n // first n elements of xs xs drop n // the rest of the collection after taking n elements xs ( n ) // the nth element of xs, complexity O(n) xs ++ ys // concatenation, complexity O(n) xs . reverse // reverse the order, complexity O(n) xs updated ( n , x ) // same list than xs, except at index n where it contains x, complexity O(n) xs indexOf x // the index of the first element equal to x (-1 otherwise) xs contains x // same as xs indexOf x = 0 xs filter p // returns a list of the elements that satisfy the predicate p xs filterNot p // filter with negated p xs partition p // same as (xs filter p, xs filterNot p) xs takeWhile p // the longest prefix consisting of elements that satisfy p xs dropWhile p // the remainder of the list after any leading element satisfying p have been removed xs span p // same as (xs takeWhile p, xs dropWhile p) List ( x1 , ..., xn ) reduceLeft op // (...(x1 op x2) op x3) op ...) op xn List ( x1 , ..., xn ). foldLeft ( z )( op ) // (...( z op x1) op x2) op ...) op xn List ( x1 , ..., xn ) reduceRight op // x1 op (... (x{n-1} op xn) ...) List ( x1 , ..., xn ). foldRight ( z )( op ) // x1 op (... ( xn op z) ...) xs exists p // true if there is at least one element for which predicate p is true xs forall p // true if p(x) is true for all elements xs zip ys // returns a list of pairs which groups elements with same index together xs unzip // opposite of zip: returns a pair of two lists xs . flatMap f // applies the function to all elements and concatenates the result xs . sum // sum of elements of the numeric collection xs . product // product of elements of the numeric collection xs . max // maximum of collection xs . min // minimum of collection xs . flatten // flattens a collection of collection into a single-level collection xs groupBy f // returns a map which points to a list of elements xs distinct // sequence of distinct entries (removes duplicates) x +: xs // creates a new collection with leading element x xs :+ x // creates a new collection with trailing element x // Operations on maps val myMap = Map ( I - 1 , V - 5 , X - 10 ) // create a map myMap ( I ) // = 1 myMap ( A ) // = java.util.NoSuchElementException myMap get A // = None myMap get I // = Some(1) myMap . updated ( V , 15 ) // returns a new map where V maps to 15 (entry is updated) // if the key ( V here) does not exist, a new entry is added // Operations on Streams val xs = Stream ( 1 , 2 , 3 ) val xs = Stream . cons ( 1 , Stream . cons ( 2 , Stream . cons ( 3 , Stream . empty ))) // same as above ( 1 to 1000 ). toStream // = Stream(1, ?) x #:: xs // Same as Stream.cons(x, xs) // In the Stream s cons operator, the second parameter (the tail) // is defined as a call by name parameter. // Note that x::xs always produces a List","title":"Collections snippet"},{"location":"scala/#pairs-similar-for-larger-tuples","text":"1 2 3 4 5 6 7 val pair = ( answer , 42 ) // type: (String, Int) val x = ( x - 90 ) // type: (String, Int) val y = ( y - - 5 ) // type: (String, Int) val z = ( z - 0 ) // type: (String, Int) val ( label , value ) = pair // label = answer , value = 42 pair . _1 // answer pair . _2 // 42","title":"Pairs (similar for larger Tuples)"},{"location":"scala/#ordering","text":"There is already a class in the standard library that represents orderings: scala.math.Ordering[T] which contains comparison functions such as lt() and gt() for standard types. Types with a single natural ordering should inherit from the trait scala.math.Ordered[T] . 1 2 3 4 5 import math.Ordering def msort [ T ]( xs : List [ T ])( implicit ord : Ordering ) = { ...} msort ( fruits )( Ordering . String ) msort ( fruits ) // the compiler figures out the right ordering","title":"Ordering"},{"location":"scala/#map-and-flatmap","text":"Abstract To be added","title":"map() and flatMap()"},{"location":"scala/#category-theory","text":"Abstract To be added","title":"Category Theory"},{"location":"scala/#algrebraic-data-type","text":"Abstract To be added","title":"Algrebraic Data Type"},{"location":"scala/#typeclass","text":"Quote [...] Type class is a class (group) of types, which satisfy some contract defined in a trait with addition that such functionality (trait and implementation) can be added without any changes to the original code. One could say that the same could be achieved by extending a simple trait, but with type classes it is not necessary to predict such a need beforehand. There is no special syntax in Scala to express a type class, but the same functionality can be achieved using constructs that already exist in the language. That\u2019s what makes it a little difficult for newcomers to spot a type class in code. A typical implementation of a type class uses some syntactic sugar as well, which also doesn\u2019t make it clear right away what we are dealing with . https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html","title":"Typeclass"},{"location":"scala/#monoid","text":"The Monoid is essentially the first purely algebraic data structures. The term monoid is taken from the Category Theory , and it means a category with one object. This kind of algebraic data structures are the corner stone of the technique that gives us the ability to write polymorphic functions . A Monoid is made of: A type T A binary operation, which is associative, that takes two values of type T and combines them into one A value zero : T which is an identity for the associative operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * It is defined by some type A, an associative binary operation that takes */ trait Monoid [ T ] { // associativity // op(op(x, y), z) == op(x, op(y, z)) def op ( x : T , y : T ) : T // identity // op(x, zero) == op(zero, x) == x def zero : T } // example val stringMonoid = new Monoid [ String ] { override def op ( x : String , y : String ) : String = x + y override def zero : String = }","title":"Monoid"},{"location":"scala/#fold-foldright-and-foldleft","text":"Abstract To be added","title":"fold: foldRight() and foldLeft()"},{"location":"scala/#sbt","text":"Defining dependencies and Settins in /project","title":"SBT"},{"location":"scala/#functor","text":"A Functor is just a type constructor for which map can be implemented: 1 2 3 trait Functor [ F [ _ ]] { def map [ T , R ]( fa : F [ T ])( f : T = R ) : F [ R ] }","title":"Functor"},{"location":"scala/#monad","text":"Monads are like wrappers that provide us with two fundamental operations: identity (that we refer as unit in Scala - or pure ) bind ( flatMap in Scala) Monads in Category Theory In Category Theory, a Monad is a Functor equipped with a pair of \"natural transformations\" satisfying the laws of associativity and identity. And then a question arises spontaneously: how should I describe a Monad in Scala? 1 2 3 4 5 trait M [ T ] { def flatMap [ T ]( f : T = M [ R ]) : M [ R ] } def unit [ T ]( x : T ) : M [ T ] As you might have supposed unit[MyType](x) performs the wrapping into a Monad[MyType] . It's pretty clear that we defined the method unit() outside the trait body because we don\u2019t want to invoke it upon the existing monadic object. Monad laws If we have some basic value x , a monad instance m (holding some value) and functions f and g of type Int \u2192 M[Int] , we can write the laws as follows: left-identity law : 1 unit ( x ). flatMap ( f ) == f ( x ) right-identity law : 1 m . flatMap ( unit ) == m associativity law : 1 m . flatMap ( f ). flatMap ( g ) == m . flatMap ( x \u21d2 f ( x ). flatMap ( g )) On flatMap 1 2 map with T = M[R] flatten M[T] ------------------------- M[M[R]] ----------- M[R] Why do we need monads? Functions should (to be simpler) return only one thing . Solution: let's create a new type of data to be returned, a \" boxing type \" that encloses maybe a real or be simply nothing. Hence, we can have g: (x: Real, y: Real) = Option[Real] . OK, but\u2026 What happens now to f(g(x,y)) ? f is not ready to consume an Option[Real] . And, we don't want to change every function we could connect with g to consume an Option[Real] . Solution: let's have a special function to \"connect\"/\"compose\"/\"link\" functions . That way, we can, behind the scenes, adapt the output of one function to feed the following one. In our case: g.flatMap(f) (connect/compose g to f ). We want flatMap to get g 's output, inspect it and, in case it is None just don't call f and return None ; or on the contrary, extract the boxed Real and feed f with it. Many other problems arise which can be solved using this same pattern: 1. Use a \"box\" to codify/store different meanings/values, and have functions like g that return those \"boxed values\". Have composers/linkers g flatMap f to help connecting g 's output to f 's input, so we don't have to change f at all. Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions (\"the program\") can share: solution StateMonad . We don't like \"impure functions\": functions that yield different output for same input. Therefore, let's mark those functions, making them to return a tagged/boxed value: IO monad. https://stackoverflow.com/a/28135478/1977778 About Monads","title":"Monad"}]}