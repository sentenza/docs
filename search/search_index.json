{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About After a lot of thinking, following the example of @niqdev , I made up my mind to create this project to collect all the useful information about what I like most: programming . This is still a collection of what I think might be useful resources for inspiring new and old developers. I chose to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre. Why doing this? Most of all because writing good software is hard , and doing it without organizing and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: Quote \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. **Now the skillful workman is very careful indeed as to what he takes into his brain-attic* . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d* \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887 Contributors @sentenza","title":"Home"},{"location":"#about","text":"After a lot of thinking, following the example of @niqdev , I made up my mind to create this project to collect all the useful information about what I like most: programming . This is still a collection of what I think might be useful resources for inspiring new and old developers. I chose to release it under the GNU General Public License v3.0 , because I honestly consider it one of the most powerful resource to help the community, giving to each other the Freedom to improve and share knowledge. For this very reason, I invite you to give your free contribution to this collection of documents . They will be always accessible and they will be Free/Libre.","title":"About"},{"location":"#why-doing-this","text":"Most of all because writing good software is hard , and doing it without organizing and keeping track of what you find useful is the act of a fool . I love to think our brains in the same way as Conan Doyle originally described it: Quote \u201cI consider that a man's brain originally is like a little empty attic, and you have to stock it with such furniture as you choose. A fool takes in all the lumber of every sort that he comes across, so that the knowledge which might be useful to him gets crowded out, or at best is jumbled up with a lot of other things, so that he has a difficulty in laying his hands upon it. **Now the skillful workman is very careful indeed as to what he takes into his brain-attic* . He will have nothing but the tools which may help him in doing his work, but of these he has a large assortment, and all in the most perfect order. It is a mistake to think that that little room has elastic walls and can distend to any extent. Depend upon it there comes a time when for every addition of knowledge you forget something that you knew before. It is of the highest importance, therefore, not to have useless facts elbowing out the useful ones.\u201d* \u2015 Arthur Conan Doyle, A Study in Scarlet Source: Wikipedia - public domain - 1887","title":"Why doing this?"},{"location":"#contributors","text":"@sentenza","title":"Contributors"},{"location":"category_theory/","text":"Category Theory A category is a purely algebraic structure consisting of \"objects\" and \"arrows\" (morphisms) that connect those objects , much like a directed graph with nodes and edges between them. A category will have objects like X , Y , Z ,etc. and arrows between objects. Importantly, arrows compose . Given an arrow f from X to Y , and another arrow g from Y to Z , their composition is an arrow from X to Z . There is also an identity arrow from every object to itself. Summoner trait Summoner [ D [ _ [ _ ]]] { def apply [ C [ _ ] : D ] : D [ C ] = implicitly [ D [ C ]] } Implicitly The scala Standard library provides a generic type class interface called implicitly def implicitly [ A ]( implicit value : A ) : A = value Thus, we can simply use implicitly to summon any value from implicit scope. We have to just provide the right type to implicitly. What is more, we can take advantage of implicitly to test implicit calls that we can't tell for sure if in the current scope or not. Functor The real objective of a Functor is to lift a regular function . Therefore, we can think of a Functor as a trait which has the ability to \"lift\" an arrow that goes from A to B to another arrow that goes from C[A] to C[B] . /** Bro, Do You Even Lift? */ trait SortOfFunctor [ C [ _ ]] { def lift1 [ A , B ]( ab : A => B ) : ( C [ A ] => C [ B ]) // If we uncurry lift() we can rewrite it as: def lift2 [ A , B ]( ab : A => B )( ca : C [ A ]) : C [ B ] } And now looking at lift2() we can transform it into something that we already know quite well: map() . And, most importantly, Functor is just a type constructor for which map can be implemented: trait Functor [ C [ _ ]] { def map [ A , B ]( ca : C [ A ])( ab : A => B ) : C [ B ] } object Functor extends Summoner [ Functor ] // Without using a Summoner we would have had: // object Functor { // def apply[C[_]: Functor]: Functor[C] = implicitly[Functor[C]] // } Quote Any type F with a function like map() is a Functor, with one additional restriction: the map function has to preserve the \"structure\" of the value it's mapping over . Thus map(x) preserves the structure of x , mofifying only the elements contained within, while the shape of the structure itself is left intact. And now we can simply rewrite our initial lifting function using map() : def lift ( f : A => B ) : ( F [ A ] => F [ B ]) = _ map f Visually, the previous operation could be represented by the following diagram ( source ): Category Theory - Laws In category theory, functors take the objects and morphisms of a category and map them to a different category. By definition, this new category must have an identity and the ability to compose morphisms, but we don't have to check that because the following laws must hold. // identity map ( id ) === id // composition compose ( map ( f ), map ( g )) === map ( compose ( f , g )) As stated befone, we can think of a category as a network of objects with morphisms that connect them. So a functor would map one category to the other without breaking the network . Monoid In category theory , a monoid is a category with one object. The Monoid is essentially the first purely algebraic data structure. This kind of algebraic data structures are the corner stone of the technique that gives us a ability to write polymorphic functions . A Monoid is made of: A type T A binary operation, which is associative, that takes two values of type T and combines them into one A value zero: T which is an identity for the associative operation trait Monoid [ T ] { // associativity // op(op(x, y), z) == op(x, op(y, z)) def op ( x : T , y : T ) : T // identity // op(x, zero) == op(zero, x) == x def zero : T } // example val stringMonoid = new Monoid [ String ] { override def op ( x : String , y : String ) : String = x + y override def zero : String = \"\" } Monad The primary purpose of Monads is to let you compose code in for expressions (binding - i.e. to glue code together) . Monads are like wrappers that provide us with two fundamental operations: identity (that we refer as unit in Scala - or pure ) bind ( flatMap in Scala) Why do we need monads? We want to have the ability to use a boxing type ( F[_] - Option[String] ), mainly because a function should return just one type and, for example, we have to attach a log message to the output value of a function At the same time we'd like to consume our new boxing types without changing our preexistent code. Solution: let's have a special function to \"connect\"/\"compose\"/\"link\" functions . That way, we can, behind the scenes, adapt the output of one function to feed the following one. g.flatMap(f) (connect/compose g to f ). We want flatMap to get g 's output, inspect it and, in case it is None just don't call f and return None ; or on the contrary, extract the boxed value and feed f with it. Many other problems arise which can be solved using this same pattern: 1. Use a \"box\" to codify/store different meanings/values, and have functions like g that return those \"boxed values\". Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions (\"the program\") can share: solution State Monad. We don't like \"impure functions\": functions that yield different output for same input. Therefore, let's mark those functions, making them to return a tagged/boxed value: IO monad. let the log of an operation be attached to the value that comes out from a computation: solution Writer Monad. https://stackoverflow.com/a/28135478/1977778 Review For-Comprehensions As we stated while introducing Monads for expressions have a very deep correllation with this category. That's mainly because a for-comprehension is syntactic sugar for map , flatMap and filter operations on collections. The general form is for (s) yield e s is a sequence of generators and filters p <- e is a generator if f is a filter If there are several generators (equivalent of a nested loop), the last generator varies faster than the first You can use { s } instead of ( s ) if you want to use multiple lines without requiring semicolons e is an element of the resulting collection Example 1 // list all combinations of numbers x and y where x is drawn from // 1 to M and y is drawn from 1 to N for ( x <- 1 to M ; y <- 1 to N ) yield ( x , y ) is equivalent to ( 1 to M ) flatMap ( x => ( 1 to N ) map ( y => ( x , y ))) Translation Rules A for-expression looks like a traditional for loop but works differently internally for (x <- e1) yield e2 is translated to e1.map(x => e2) for (x <- e1 if f) yield e2 is translated to for (x <- e1.filter(x => f)) yield e2 for (x <- e1; y <- e2) yield e3 is translated to e1.flatMap(x => for (y <- e2) yield e3) This means you can use a for-comprehension for your own type, as long as you define map , flatMap and filter . Example 2 for { i <- 1 until n j <- 1 until i if isPrime ( i + j ) } yield ( i , j ) is equivalent to for ( i <- 1 until n ; j <- 1 until i if isPrime ( i + j )) yield ( i , j ) On flatMap map with T => M[R] flatten M[T] -------------------------> M[M[R]] -----------> M[R] Defining Monads In order to define a Monad in Scala we need map() , flatMap() and a lifting method called unit . As we've already seen in the definition of Functors we could lift a value just using map() . But if we have to simply wrap an object into a new boxing type or wrapper F[_] we can define a new function that we call unit() , which is defined as follows: def unit [ A ]( a : => A ) : F [ A ] Now, while observing very carefully that function we can compare it to what the apply method does already in the definition of a new object: // We define a generic Wrapper class class Wrapper [ A ] private ( value : A ) { ... } // Then we create a companion object which will also be shipped with a factory method that will create a new Wrapper for us object Wrapper { def apply [ A ]( value : A ) : Wrapper [ A ] = new Wrapper ( value ) // Using apply() we're actually lifting A to Wrapper[A] } Basically, we created a new type Wrapper and then we attached to it a companion object that will give us the ability to create new wrappers using val w = Wrapper(value1) using a factory method. Now let's define the body of the Wrapper class, keeping in mind that in order to use for expressions over this class we need map() and flatMap() . class Wrapper [ A ] private ( value : A ) { def map [ B ]( f : A => B ) : Wrapper [ B ] = Wrapper ( f ( value )) def flatMap [ B ]( f : A => Wrapper [ B ]) : Wrapper [ B ] = f ( value ) } // The Companion object Wrapper { def apply [ A ]( value : A ) : Wrapper [ A ] = new Wrapper ( value ) } Monads in Category Theory In Category Theory, a Monad is a Functor equipped with a pair of \"natural transformations\" satisfying the laws of associativity and identity. OK, now we have all the lego blocks that we actually need to define a Monad in Scala. Note that we define a Monad as a trait and that we extends Functor. Moreover, we add unit() defining it as pure() and then we override map() , which is already defined in Functor, but in this case we take advantage of unit() to lift a value to the boxing type. Also, we redefine map() using flatMap() . trait Monad [ C [ _ ]] extends Functor [ C ] { def pure [ A ]( a : => A ) : C [ A ] @inline def unit [ A ]( a : => A ) : C [ A ] = pure ( a ) @inline def point [ A ]( a : => A ) : C [ A ] = pure ( a ) override def map [ A , B ]( ca : C [ A ])( ab : A => B ) : C [ B ] = flatMap ( ca )( a => pure ( ab ( a ))) // We needed this helper method to compose functions // def helper[A, B](ca: C[A], acb: A => C[B]): C[B] // From Helper to FlatMap def flatMap [ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] // Curried version of helper method // haskell bind @inline def bind [ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] = flatMap ( ca )( acb ) @inline def >>=[ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] = flatMap ( ca )( acb ) // >>= Haskell Logo } // Monad Type class - remember that Summoner defines an apply method // that corresponds to unit. object Monad extends Summoner [ Monad ] // extending Summoner is the same as // object Monad { def apply[C[_]: Monad]: Monad[C] = implicitly[Monad[C]] } } As you might have supposed unit[MyType](x) performs the wrapping into a Monad[MyType] . It's pretty clear that we defined the method unit() outside the trait body because we don\u2019t want to invoke it upon the existing monadic object. Monad laws If we have some basic value x , a monad instance m (holding some value) and functions f and g of type Int \u2192 M[Int] , we can write the laws as follows: left-identity law : unit(x).flatMap(f) == f(x) right-identity law : m.flatMap(unit) == m associativity law : m.flatMap(f).flatMap(g) == m.flatMap(x \u21d2 f(x).flatMap(g)) The only correct definition of Monad A monad is an implementation of one of the minimal sets of monadic combinators, satisfying the laws of associativity and identity. Links Demystifying the monad in Scala","title":"Category Theory"},{"location":"category_theory/#category-theory","text":"A category is a purely algebraic structure consisting of \"objects\" and \"arrows\" (morphisms) that connect those objects , much like a directed graph with nodes and edges between them. A category will have objects like X , Y , Z ,etc. and arrows between objects. Importantly, arrows compose . Given an arrow f from X to Y , and another arrow g from Y to Z , their composition is an arrow from X to Z . There is also an identity arrow from every object to itself.","title":"Category Theory"},{"location":"category_theory/#summoner","text":"trait Summoner [ D [ _ [ _ ]]] { def apply [ C [ _ ] : D ] : D [ C ] = implicitly [ D [ C ]] } Implicitly The scala Standard library provides a generic type class interface called implicitly def implicitly [ A ]( implicit value : A ) : A = value Thus, we can simply use implicitly to summon any value from implicit scope. We have to just provide the right type to implicitly. What is more, we can take advantage of implicitly to test implicit calls that we can't tell for sure if in the current scope or not.","title":"Summoner"},{"location":"category_theory/#functor","text":"The real objective of a Functor is to lift a regular function . Therefore, we can think of a Functor as a trait which has the ability to \"lift\" an arrow that goes from A to B to another arrow that goes from C[A] to C[B] . /** Bro, Do You Even Lift? */ trait SortOfFunctor [ C [ _ ]] { def lift1 [ A , B ]( ab : A => B ) : ( C [ A ] => C [ B ]) // If we uncurry lift() we can rewrite it as: def lift2 [ A , B ]( ab : A => B )( ca : C [ A ]) : C [ B ] } And now looking at lift2() we can transform it into something that we already know quite well: map() . And, most importantly, Functor is just a type constructor for which map can be implemented: trait Functor [ C [ _ ]] { def map [ A , B ]( ca : C [ A ])( ab : A => B ) : C [ B ] } object Functor extends Summoner [ Functor ] // Without using a Summoner we would have had: // object Functor { // def apply[C[_]: Functor]: Functor[C] = implicitly[Functor[C]] // } Quote Any type F with a function like map() is a Functor, with one additional restriction: the map function has to preserve the \"structure\" of the value it's mapping over . Thus map(x) preserves the structure of x , mofifying only the elements contained within, while the shape of the structure itself is left intact. And now we can simply rewrite our initial lifting function using map() : def lift ( f : A => B ) : ( F [ A ] => F [ B ]) = _ map f Visually, the previous operation could be represented by the following diagram ( source ): Category Theory - Laws In category theory, functors take the objects and morphisms of a category and map them to a different category. By definition, this new category must have an identity and the ability to compose morphisms, but we don't have to check that because the following laws must hold. // identity map ( id ) === id // composition compose ( map ( f ), map ( g )) === map ( compose ( f , g )) As stated befone, we can think of a category as a network of objects with morphisms that connect them. So a functor would map one category to the other without breaking the network .","title":"Functor"},{"location":"category_theory/#monoid","text":"In category theory , a monoid is a category with one object. The Monoid is essentially the first purely algebraic data structure. This kind of algebraic data structures are the corner stone of the technique that gives us a ability to write polymorphic functions . A Monoid is made of: A type T A binary operation, which is associative, that takes two values of type T and combines them into one A value zero: T which is an identity for the associative operation trait Monoid [ T ] { // associativity // op(op(x, y), z) == op(x, op(y, z)) def op ( x : T , y : T ) : T // identity // op(x, zero) == op(zero, x) == x def zero : T } // example val stringMonoid = new Monoid [ String ] { override def op ( x : String , y : String ) : String = x + y override def zero : String = \"\" }","title":"Monoid"},{"location":"category_theory/#monad","text":"The primary purpose of Monads is to let you compose code in for expressions (binding - i.e. to glue code together) . Monads are like wrappers that provide us with two fundamental operations: identity (that we refer as unit in Scala - or pure ) bind ( flatMap in Scala) Why do we need monads? We want to have the ability to use a boxing type ( F[_] - Option[String] ), mainly because a function should return just one type and, for example, we have to attach a log message to the output value of a function At the same time we'd like to consume our new boxing types without changing our preexistent code. Solution: let's have a special function to \"connect\"/\"compose\"/\"link\" functions . That way, we can, behind the scenes, adapt the output of one function to feed the following one. g.flatMap(f) (connect/compose g to f ). We want flatMap to get g 's output, inspect it and, in case it is None just don't call f and return None ; or on the contrary, extract the boxed value and feed f with it. Many other problems arise which can be solved using this same pattern: 1. Use a \"box\" to codify/store different meanings/values, and have functions like g that return those \"boxed values\". Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions (\"the program\") can share: solution State Monad. We don't like \"impure functions\": functions that yield different output for same input. Therefore, let's mark those functions, making them to return a tagged/boxed value: IO monad. let the log of an operation be attached to the value that comes out from a computation: solution Writer Monad. https://stackoverflow.com/a/28135478/1977778","title":"Monad"},{"location":"category_theory/#review-for-comprehensions","text":"As we stated while introducing Monads for expressions have a very deep correllation with this category. That's mainly because a for-comprehension is syntactic sugar for map , flatMap and filter operations on collections. The general form is for (s) yield e s is a sequence of generators and filters p <- e is a generator if f is a filter If there are several generators (equivalent of a nested loop), the last generator varies faster than the first You can use { s } instead of ( s ) if you want to use multiple lines without requiring semicolons e is an element of the resulting collection Example 1 // list all combinations of numbers x and y where x is drawn from // 1 to M and y is drawn from 1 to N for ( x <- 1 to M ; y <- 1 to N ) yield ( x , y ) is equivalent to ( 1 to M ) flatMap ( x => ( 1 to N ) map ( y => ( x , y ))) Translation Rules A for-expression looks like a traditional for loop but works differently internally for (x <- e1) yield e2 is translated to e1.map(x => e2) for (x <- e1 if f) yield e2 is translated to for (x <- e1.filter(x => f)) yield e2 for (x <- e1; y <- e2) yield e3 is translated to e1.flatMap(x => for (y <- e2) yield e3) This means you can use a for-comprehension for your own type, as long as you define map , flatMap and filter . Example 2 for { i <- 1 until n j <- 1 until i if isPrime ( i + j ) } yield ( i , j ) is equivalent to for ( i <- 1 until n ; j <- 1 until i if isPrime ( i + j )) yield ( i , j ) On flatMap map with T => M[R] flatten M[T] -------------------------> M[M[R]] -----------> M[R]","title":"Review For-Comprehensions"},{"location":"category_theory/#defining-monads","text":"In order to define a Monad in Scala we need map() , flatMap() and a lifting method called unit . As we've already seen in the definition of Functors we could lift a value just using map() . But if we have to simply wrap an object into a new boxing type or wrapper F[_] we can define a new function that we call unit() , which is defined as follows: def unit [ A ]( a : => A ) : F [ A ] Now, while observing very carefully that function we can compare it to what the apply method does already in the definition of a new object: // We define a generic Wrapper class class Wrapper [ A ] private ( value : A ) { ... } // Then we create a companion object which will also be shipped with a factory method that will create a new Wrapper for us object Wrapper { def apply [ A ]( value : A ) : Wrapper [ A ] = new Wrapper ( value ) // Using apply() we're actually lifting A to Wrapper[A] } Basically, we created a new type Wrapper and then we attached to it a companion object that will give us the ability to create new wrappers using val w = Wrapper(value1) using a factory method. Now let's define the body of the Wrapper class, keeping in mind that in order to use for expressions over this class we need map() and flatMap() . class Wrapper [ A ] private ( value : A ) { def map [ B ]( f : A => B ) : Wrapper [ B ] = Wrapper ( f ( value )) def flatMap [ B ]( f : A => Wrapper [ B ]) : Wrapper [ B ] = f ( value ) } // The Companion object Wrapper { def apply [ A ]( value : A ) : Wrapper [ A ] = new Wrapper ( value ) } Monads in Category Theory In Category Theory, a Monad is a Functor equipped with a pair of \"natural transformations\" satisfying the laws of associativity and identity. OK, now we have all the lego blocks that we actually need to define a Monad in Scala. Note that we define a Monad as a trait and that we extends Functor. Moreover, we add unit() defining it as pure() and then we override map() , which is already defined in Functor, but in this case we take advantage of unit() to lift a value to the boxing type. Also, we redefine map() using flatMap() . trait Monad [ C [ _ ]] extends Functor [ C ] { def pure [ A ]( a : => A ) : C [ A ] @inline def unit [ A ]( a : => A ) : C [ A ] = pure ( a ) @inline def point [ A ]( a : => A ) : C [ A ] = pure ( a ) override def map [ A , B ]( ca : C [ A ])( ab : A => B ) : C [ B ] = flatMap ( ca )( a => pure ( ab ( a ))) // We needed this helper method to compose functions // def helper[A, B](ca: C[A], acb: A => C[B]): C[B] // From Helper to FlatMap def flatMap [ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] // Curried version of helper method // haskell bind @inline def bind [ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] = flatMap ( ca )( acb ) @inline def >>=[ A , B ]( ca : C [ A ])( acb : A => C [ B ]) : C [ B ] = flatMap ( ca )( acb ) // >>= Haskell Logo } // Monad Type class - remember that Summoner defines an apply method // that corresponds to unit. object Monad extends Summoner [ Monad ] // extending Summoner is the same as // object Monad { def apply[C[_]: Monad]: Monad[C] = implicitly[Monad[C]] } } As you might have supposed unit[MyType](x) performs the wrapping into a Monad[MyType] . It's pretty clear that we defined the method unit() outside the trait body because we don\u2019t want to invoke it upon the existing monadic object. Monad laws If we have some basic value x , a monad instance m (holding some value) and functions f and g of type Int \u2192 M[Int] , we can write the laws as follows: left-identity law : unit(x).flatMap(f) == f(x) right-identity law : m.flatMap(unit) == m associativity law : m.flatMap(f).flatMap(g) == m.flatMap(x \u21d2 f(x).flatMap(g)) The only correct definition of Monad A monad is an implementation of one of the minimal sets of monadic combinators, satisfying the laws of associativity and identity.","title":"Defining Monads"},{"location":"category_theory/#links","text":"Demystifying the monad in Scala","title":"Links"},{"location":"kubernetes/","text":"So Kubernetes is pronounced /koo-ber-nay'-tace/ and means \"sailing master\" Via @francesc Terminology Node : A single virtual or physical machine in a Kubernetes cluster. Cluster: A group of nodes firewalled from the internet, that are the primary compute resources managed by Kubernetes. Edge router: A router that enforces the firewall policy for your cluster. This could be a gateway managed by a cloud provider or a physical piece of hardware. Cluster network: A set of links, logical or physical, that facilitate communication within a cluster according to the Kubernetes networking model . Examples of a Cluster network include Overlays such as flannel or SDNs such as OVS. Service: A Kubernetes Service that identifies a set of pods using label selectors. Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network. What is a pod?? A pod is a group of one or more containers (such as Docker containers), with shared storage/network, and a specification for how to run the containers. A pod\u2019s contents are always co-located and co-scheduled, and run in a shared context. Containers within a pod share an IP address and port space, and can find each other via localhost. They can also communicate with each other using standard inter-process communications like SystemV semaphores or POSIX shared memory. Containers in different pods have distinct IP addresses and can not communicate by IPC without special configuration. These containers usually communicate with each other via Pod IP addresses. In terms of Docker constructs, a pod is modelled as a group of Docker containers with shared namespaces and shared volumes . Kubernetes \"plugins\" Helm Tiller : Helm is a package manager for Kubernetes and is required to install all the other applications. It is installed in its own pod inside the cluster which can run the helm CLI in a safe environment. Ingress : Ingress can provide load balancing, SSL termination, and name-based virtual hosting. It acts as a web proxy for your applications and is useful if you want to use Auto DevOps or deploy your own web apps. Prometheus : Prometheus is an open-source monitoring and alerting system useful to supervise your deployed applications. How to manage the Google Kubernetes Engine The first step is to check the defined clusters [using the Google Cloud Platform console][gcp-console]. The most common target is, at first, to build and push a containarised application, which means that we start creating a new docker image in our machine, then after checking it locally, we push the image to a docker container registry . Using GCP all these operations can be done by using a mix of docker , gcloud and kubectl commands. First things first, we must create one or more images using the instructions provided here . After that, one can follow the instructions of this gcloud tutorial . Setting a static IP and a custom domain for the application In our case we can assign a static IP address for the service created one step above. The best way to achieve this, IMHO, is the web interface and precisely here . Update the image used for the current Kubernetes POD Build a new snapshot optimized for production ng build --prod Create a new image and tag it with a new version Test the new image locally Push the newly created image to the container registry To update the deployed container we can use the set command: kubectl set image deployment/together-rx ... Problem: A frequent question that comes up on Slack and Stack Overflow is how to trigger an update to a Deployment/RS/RC when the image tag hasn't changed but the underlying image has. Consider: There is an existing Deployment with image foo:latest User builds a new image foo:latest User pushes foo:latest to their registry User wants to do something here to tell the Deployment to pull the new image and do a rolling-update of existing pods Possible solution for our current scenario: you are using 'latest' for testing (this is the \"no sed\" use case), in this case, downtime is fine, and indeed the right approach is likely to completely blow away your stack and redeploy from scratch to get a clean run (=> kubectl set <...> ). Keep reading here . Delete a Kubernetes service To stop and delete a Kubernetes instance/service corresponding to the image we created and then exposed we should instruct Kubernetes to tell the Load Balancer to delete the provisioned service with a simple command like that: kubectl delete service container-1 NOTE: The load balancer is deleted asynchronously in the background when you run kubectl delete . Wait until the load balancer is deleted by watching the output of the following command: gcloud compute forwarding-rules list Storage and DBs on GKE High Availability PostgreSQL and Kubernetes with Google Cloud How to pronounce Kubernetes","title":"Kubernetes"},{"location":"kubernetes/#terminology","text":"Node : A single virtual or physical machine in a Kubernetes cluster. Cluster: A group of nodes firewalled from the internet, that are the primary compute resources managed by Kubernetes. Edge router: A router that enforces the firewall policy for your cluster. This could be a gateway managed by a cloud provider or a physical piece of hardware. Cluster network: A set of links, logical or physical, that facilitate communication within a cluster according to the Kubernetes networking model . Examples of a Cluster network include Overlays such as flannel or SDNs such as OVS. Service: A Kubernetes Service that identifies a set of pods using label selectors. Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network.","title":"Terminology"},{"location":"kubernetes/#what-is-a-pod","text":"A pod is a group of one or more containers (such as Docker containers), with shared storage/network, and a specification for how to run the containers. A pod\u2019s contents are always co-located and co-scheduled, and run in a shared context. Containers within a pod share an IP address and port space, and can find each other via localhost. They can also communicate with each other using standard inter-process communications like SystemV semaphores or POSIX shared memory. Containers in different pods have distinct IP addresses and can not communicate by IPC without special configuration. These containers usually communicate with each other via Pod IP addresses. In terms of Docker constructs, a pod is modelled as a group of Docker containers with shared namespaces and shared volumes .","title":"What is a pod??"},{"location":"kubernetes/#kubernetes-plugins","text":"Helm Tiller : Helm is a package manager for Kubernetes and is required to install all the other applications. It is installed in its own pod inside the cluster which can run the helm CLI in a safe environment. Ingress : Ingress can provide load balancing, SSL termination, and name-based virtual hosting. It acts as a web proxy for your applications and is useful if you want to use Auto DevOps or deploy your own web apps. Prometheus : Prometheus is an open-source monitoring and alerting system useful to supervise your deployed applications.","title":"Kubernetes \"plugins\""},{"location":"kubernetes/#how-to-manage-the-google-kubernetes-engine","text":"The first step is to check the defined clusters [using the Google Cloud Platform console][gcp-console]. The most common target is, at first, to build and push a containarised application, which means that we start creating a new docker image in our machine, then after checking it locally, we push the image to a docker container registry . Using GCP all these operations can be done by using a mix of docker , gcloud and kubectl commands. First things first, we must create one or more images using the instructions provided here . After that, one can follow the instructions of this gcloud tutorial .","title":"How to manage the Google Kubernetes Engine"},{"location":"kubernetes/#setting-a-static-ip-and-a-custom-domain-for-the-application","text":"In our case we can assign a static IP address for the service created one step above. The best way to achieve this, IMHO, is the web interface and precisely here .","title":"Setting a static IP and a custom domain for the application"},{"location":"kubernetes/#update-the-image-used-for-the-current-kubernetes-pod","text":"Build a new snapshot optimized for production ng build --prod Create a new image and tag it with a new version Test the new image locally Push the newly created image to the container registry To update the deployed container we can use the set command: kubectl set image deployment/together-rx ... Problem: A frequent question that comes up on Slack and Stack Overflow is how to trigger an update to a Deployment/RS/RC when the image tag hasn't changed but the underlying image has. Consider: There is an existing Deployment with image foo:latest User builds a new image foo:latest User pushes foo:latest to their registry User wants to do something here to tell the Deployment to pull the new image and do a rolling-update of existing pods Possible solution for our current scenario: you are using 'latest' for testing (this is the \"no sed\" use case), in this case, downtime is fine, and indeed the right approach is likely to completely blow away your stack and redeploy from scratch to get a clean run (=> kubectl set <...> ). Keep reading here .","title":"Update the image used for the current Kubernetes POD"},{"location":"kubernetes/#delete-a-kubernetes-service","text":"To stop and delete a Kubernetes instance/service corresponding to the image we created and then exposed we should instruct Kubernetes to tell the Load Balancer to delete the provisioned service with a simple command like that: kubectl delete service container-1 NOTE: The load balancer is deleted asynchronously in the background when you run kubectl delete . Wait until the load balancer is deleted by watching the output of the following command: gcloud compute forwarding-rules list","title":"Delete a Kubernetes service"},{"location":"kubernetes/#storage-and-dbs-on-gke","text":"High Availability PostgreSQL and Kubernetes with Google Cloud How to pronounce Kubernetes","title":"Storage and DBs on GKE"},{"location":"links/","text":"Links and external resources Functional Programming Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming FP Papers Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky ) Scala Books Programming in Scala (2016) by Martin Odersky, Lex Spoon, and Bill Venners Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason ( The **Red Book** ) A companion booklet to \"Functional Programming in Scala\" (PDF) by R\u00fanar \u00d3li Bjarnason Functional Programming, Simplified (2017) by Alvin Alexander Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless Readings Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples Cats and Shapeless Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk) Haskell and OCaml Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Links"},{"location":"links/#links-and-external-resources","text":"","title":"Links and external resources"},{"location":"links/#functional-programming","text":"Category Theory for Programmers Functional Programming For The Rest of Us Parallelism and concurrency need different tools What the Heck are Algebraic Data Types? by Daniel Eklund Functors, Applicatives, And Monads In Pictures A practical introduction to functional programming Functional Programming Basics by Robert C. Martin (Uncle Bob) The Downfall of Imperative Programming","title":"Functional Programming"},{"location":"links/#fp-papers","text":"Why Functional Programming Matters (J. Hughes The University, Glasgow, 1990) Monoids: Theme and Variations (B. Yorgey, 2012) The Essence of the Iterator Pattern (J. Gibbons and B. Oliveira, Oxford University Computing Laboratory) Applicative programming with effects (C. McBride, University of Nottingham - R. Paterson, City University, London) Stack Safety for Free (Phil Freeman, 2015) Stackless Scala With Free Monads (R\u00fanar \u00d3li Bjarnason) Type Classes as Objects and Implicits (B. Oliveira, A. Moors, M. Odersky )","title":"FP Papers"},{"location":"links/#scala","text":"","title":"Scala"},{"location":"links/#books","text":"Programming in Scala (2016) by Martin Odersky, Lex Spoon, and Bill Venners Functional Programming in Scala (2014) by Paul Chiusano and Runar Bjarnason ( The **Red Book** ) A companion booklet to \"Functional Programming in Scala\" (PDF) by R\u00fanar \u00d3li Bjarnason Functional Programming, Simplified (2017) by Alvin Alexander Functional Programming for Mortals with Scalaz (2018) by Sam Halliday Scala with Cats The Type Astronaut's Guide to Shapeless","title":"Books"},{"location":"links/#readings","text":"Scala's Types of Types Typeclasses in scala - Illustrated with cats Algebraic Data Types in Scala by Alvin Alexander More on Sealed Traits in Scala Generalized type constraints in Scala (without a PhD) First steps with monads in Scala Demystifying the Monad in Scala Stackless Scala Rethinking MonadError Free monads - what? and why? Free Monad examples","title":"Readings"},{"location":"links/#cats-and-shapeless","text":"Scala Cats library for dummies Cats Infographic Overview of free monad in Cats An IO monad for Cats ScalaFP: Firsthand With Scala-Cats Shapeless for Mortals (2015) by Sam Halliday (Talk)","title":"Cats and Shapeless"},{"location":"links/#haskell-and-ocaml","text":"Learn You a Haskell for Great Good! A Quick Tour of Haskell Syntax OCaml taste","title":"Haskell and OCaml"},{"location":"scala/","text":"Scala Evaluation rules def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort ( x : List [ Double ]) // call by value def sort ( x : => List [ Double ]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction ( ds : Double* ) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function) Type Parameters Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. class TypedClass [ F ]( arg1 : F ) { ??? } new TypedClass [ Int ]( 1 ) new TypedClass ( 1 ) // the type is being inferred, i.e. determined based on the value arguments Conventionally, the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It's also possible to restrict the type being used, e.g. def func [ T <: TopLevel ]( arg : T ) : T = { ... } // T must derive from TopLevel or be TopLevel def func [ T >: Level1 ]( arg : T ) : T = { ... } // T must be a supertype of Level1 def func [ T >: Level1 <: Top Level ]( arg : T ) : T = { ... } Variance Quote Variance being a tricky business, users usually get it wrong , and they come away thinking that wildcard and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available. - Programming in Scala Upper Bounds: [S <: T] means: S is a subtype of T. Let's suppose that T is actually an Iterable , then S could one of Seq , List or Iterable . Lower Bounds: [S >: T] means: S is a supertype of T, or T is a subtype of S. So, if T is a List , S could be one of List , Seq , Iterable , or AnyRef . Mixed Bounds: [S >: T2 <: T1] means: s is any type on interval between T1 and T2. In this case we have basically a mix of the two cases above. Let's consider NonEmpty <: IntSet , then can we infer that List[NonEmpty] <: List[IntSet] ? Intuitively, this makes sense: a list of non-empty sets is a special case of a list of arbitrary sets. We call types for which this relationship holds covariant because their subtyping relationship varies with the type parameter. Thus Lists in scala are covariant . Does covariance make sense for all types, not just for List? No. For instance, in Scala, arrays are not covariant . When does it make sense to subtype one type with another? It is safe to assume that a type T is a subtype of a type U ( T <: U ) if you can substitute a value of type T wherever a value of type U is required. This is called the Liskov Substitution Principle . Liskov Substitution Principle https://twitter.com/javi/status/1004821965868109824 Say C[T] is a parameterized type, and A, B are types such that: Given A <: B (A is a subtype of B) If C[A] <: C[B] , C is covariant If C[A] >: C[B] , C is contravariant Neither C[A] or C[B] is a subtype of the other, then C is invariant (or \"nonvariant\" ). Scala lets you declare the variance of a type by annotating the type parameter: class C [ +A ] { ... } // C is covariant class C [ -A ] { ... } // C is contravariant class C [ A ] { ... } // C is invariant So, given that Any > AnyRef > IntSet > Empty and NonEmpty , if type A = IntSet => NonEmpty type B = NonEmpty => IntSet According to the Liskov Principle => A <: B , since B can return an Empty or NonEmpty, but A can return only NonEmpty. For a function, if A2 <: A1 and B1 <: B2 , then A1 => B1 <: A2 => B2 . The consequence is that functions must be contravariant in their argument types and covariant in their result types . /** The Scala Function1 S => T */ trait Function1 [ -S , +T ] { // S is contravariant, while T is covariant def apply ( x : S ) : T } This example shows that functions are contravariant in argument types and covariant in return types. package io.github.sentenza.cars class Car {} class SportsCar extends Car {} class Ferrari extends SportsCar {} object morecovariance extends App { // Test 1: Works as expected def test1 ( arg : SportsCar => SportsCar ) = { new SportsCar } def foo1 ( arg : Car ) : Ferrari = { new Ferrari } def foo2 ( arg : SportsCar ) : Car = { new Ferrari } def foo3 ( arg : Ferrari ) : Ferrari = { new Ferrari } test1 ( foo1 ) // compiles test1 ( foo2 ) // Fails due to wrong return type. test1 ( foo3 ) // Fails due to wrong parameter type } Find out more about variance in Covariance And Contravariance in Scala Type constructor and Variance Abstract To be added pag. 392 of the White Scala Manual Objects and Code organization Quote Scala has no globally visible methods: every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods. From Programming in Scala - Second edition (by M. Odersky, L. Spoon, B. Venners) As you can read above, I introduced Objects in terms of the functions they contain . It's very important to stress on this aspect, because Classes and Objects should be seen under a different light using Scala, especially if you come from an imperative OOP language, like Java or C++. They are just a way to organise your functions and at some point, using traits, objects (companion objects) and case classes (data constructors) you will eventually be able to build up your coding architecture based on types and composition of functions. About Case Class General object hierarchy Note All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void Factory Object The following example has been taken from Programming in Scala : abstract class Element { def contents : Array [ String ] def height : Int = contents . length def width : Int = if ( height == 0 ) 0 else contents ( 0 ). length } class ArrayElements ( val contents : Array [ String ]) extends Element // Invoking superclass constructor while extending the class itself class LineElement ( s : String ) extends ArrayElement ( Array ( s )) { override def width = s . length // Int is inferred override def width = 1 } class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } Now, what we can do is defining a Factory Object which contains methods that construct other objects, without exposing each class implementation. Basically, we can hide each class inside a Singleton Object, which will represent just a tag for the overloaded methods that will give us the ability to instantiate each subclass dinamically, and using polymorphism at the same time. Important Note that OOP is not a paradigm, but it's just a way to define our code structure in a logic manner that is similar to playing with LEGOs. OOP can be seen like an orthogonal dimension compared to functional, declarative or imperative paradigms. // We start defining a Singleton Object object Element { // we can now hide classes as private fields of this object private class ArrayElements ( val contents : Array [ String ] ) extends Element private class LineElement ( s : String ) extends Element { val contents = Array ( s ) override def width = s . length override def width = 1 } private class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } // FACTORY def elem ( contents : Array [ String ]) : Element = new ArrayElement ( contents ) def elem ( chr : Char , width : Int , heigth : Int ) : Element = new UniformElement ( chr , width , height ) def elem ( line : String ) : Elem = new LineElement ( line ) } Objects creation are centralized and the details now are hidden. Open/Closed Principle This will eventually give an easy way to understand how to use these elements, and at the same time this small change will give the developer the Open/Closed Principle for free because less detail is exposed. \u201cSoftware entities \u2026 should be open for extension, but closed for modification.\u201d This provides more opportunities to change the implementation of the library without breaking client code . At the same time a class will have a single responsibility, and only one potential change in the software\u2019s specification should be able to affect the specification of the class ( Single Responsibility Principle ). So, writing SOLID code pays off at the end. Factory method In Java you can create a private constructor by making it private . In Scala one can achieve the same behaviour prepending the private modifier to the default constructor. class Point private ( coordX : Float , coordY : Float ) { val x = coordX val y = coordY /** Public auxiliary constructor * Setting the point at the origin of the Cartesian axes * calling the default private constructor using the */ def this () = this ( 0.0 , 0.0 ) def getPoint = ( x , y ) } You cannot instantiate a new point using the default constructor: val errorPoint = new Point ( 45.9 , 21.08 ) // ERROR val correctPoint = new Point () // (0.0, 0.0) A possible solution to define a new Point is given by the usage of a companion object and a factory method that will give us a convenient way to define a new object, without actually call the new operator. To do so one can add the apply() method to the newly created object, which will have the same acess rights to the Point class if placed in the same file. Therefore, the apply() method will be able to use the private construction of the Point class and then it will become a factory method : class Point [ T <: Double ] private ( coordX : T , coordY : T ) { ... } object Point { def apply [ T <: Double ]( x : T , y : T ) = new Point [ T ]( x , y ) } Collections Scala defines several collection classes: Base Classes Iterable (collections you can iterate on) Seq (ordered sequences) Set Map (lookup data structure) Immutable Collections List (linked list, provides fast sequential access) Stream (same as List, except that the tail is evaluated only on demand) Vector (array-like type, implemented as tree of blocks, provides fast random access) Range (ordered sequence of integers with equal spacing) String (Java type, implicitly converted to a character sequence, so you can treat every string like a Seq[Char] ) Map (collection that maps keys to values) Set (collection without duplicate elements) Mutable Collections Array (Scala arrays are native JVM arrays at runtime, therefore they are very performant) Scala also has mutable maps and sets; these should only be used if there are performance issues with immutable types Collections snippet Snippet val r : Range = 1 until 5 // 1, 2, 3, 4 val s : Range = 1 to 5 // 1, 2, 3, 4, 5 1 to 10 by 3 // 1, 4, 7, 10 6 to 1 by - 2 // 6, 4, 2 // Operations on sequences val xs = List (...) xs . length // number of elements, complexity O(n) xs . last // last element (exception if xs is empty), complexity O(n) xs . init // all elements of xs but the last (exception if xs is empty), complexity O(n) xs take n // first n elements of xs xs drop n // the rest of the collection after taking n elements xs ( n ) // the nth element of xs, complexity O(n) xs ++ ys // concatenation, complexity O(n) xs . reverse // reverse the order, complexity O(n) xs updated ( n , x ) // same list than xs, except at index n where it contains x, complexity O(n) xs indexOf x // the index of the first element equal to x (-1 otherwise) xs contains x // same as xs indexOf x >= 0 xs filter p // returns a list of the elements that satisfy the predicate p xs filterNot p // filter with negated p xs partition p // same as (xs filter p, xs filterNot p) xs takeWhile p // the longest prefix consisting of elements that satisfy p xs dropWhile p // the remainder of the list after any leading element satisfying p have been removed xs span p // same as (xs takeWhile p, xs dropWhile p) List ( x1 , ..., xn ) reduceLeft op // (...(x1 op x2) op x3) op ...) op xn List ( x1 , ..., xn ). foldLeft ( z )( op ) // (...( z op x1) op x2) op ...) op xn List ( x1 , ..., xn ) reduceRight op // x1 op (... (x{n-1} op xn) ...) List ( x1 , ..., xn ). foldRight ( z )( op ) // x1 op (... ( xn op z) ...) xs exists p // true if there is at least one element for which predicate p is true xs forall p // true if p(x) is true for all elements xs zip ys // returns a list of pairs which groups elements with same index together xs unzip // opposite of zip: returns a pair of two lists xs . flatMap f // applies the function to all elements and concatenates the result xs . sum // sum of elements of the numeric collection xs . product // product of elements of the numeric collection xs . max // maximum of collection xs . min // minimum of collection xs . flatten // flattens a collection of collection into a single-level collection xs groupBy f // returns a map which points to a list of elements xs distinct // sequence of distinct entries (removes duplicates) x +: xs // creates a new collection with leading element x xs :+ x // creates a new collection with trailing element x // Operations on maps val myMap = Map ( \"I\" -> 1 , \"V\" -> 5 , \"X\" -> 10 ) // create a map myMap ( \"I\" ) // => 1 myMap ( \"A\" ) // => java.util.NoSuchElementException myMap get \"A\" // => None myMap get \"I\" // => Some(1) myMap . updated ( \"V\" , 15 ) // returns a new map where \"V\" maps to 15 (entry is updated) // if the key (\"V\" here) does not exist, a new entry is added // Operations on Streams val xs = Stream ( 1 , 2 , 3 ) val xs = Stream . cons ( 1 , Stream . cons ( 2 , Stream . cons ( 3 , Stream . empty ))) // same as above ( 1 to 1000 ). toStream // => Stream(1, ?) x #:: xs // Same as Stream.cons(x, xs) // In the Stream's cons operator, the second parameter (the tail) // is defined as a \"call by name\" parameter. // Note that x::xs always produces a List Pairs (similar for larger Tuples) val pair = ( \"answer\" , 42 ) // type: (String, Int) val x = ( \"x\" -> 90 ) // type: (String, Int) val y = ( \"y\" -> - 5 ) // type: (String, Int) val z = ( \"z\" -> 0 ) // type: (String, Int) val ( label , value ) = pair // label = \"answer\", value = 42 pair . _1 // \"answer\" pair . _2 // 42 Ordering There is already a class in the standard library that represents orderings: scala.math.Ordering[T] which contains comparison functions such as lt() and gt() for standard types. Types with a single natural ordering should inherit from the trait scala.math.Ordered[T] . import math.Ordering def msort [ T ]( xs : List [ T ])( implicit ord : Ordering ) = { ...} msort ( fruits )( Ordering . String ) msort ( fruits ) // the compiler figures out the right ordering Typeclass Quote [...] Type class is a class (group) of types, which satisfy some contract defined in a trait with addition that such functionality (trait and implementation) can be added without any changes to the original code. One could say that the same could be achieved by extending a simple trait, but with type classes it is not necessary to predict such a need beforehand. There is no special syntax in Scala to express a type class, but the same functionality can be achieved using constructs that already exist in the language. **That\u2019s what makes it a little difficult for newcomers to spot a type class in code. A typical implementation of a type class uses some syntactic sugar as well, which also doesn\u2019t make it clear right away what we are dealing with* .* https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html SBT Defining dependencies and Settins in /project","title":"Scala"},{"location":"scala/#scala","text":"","title":"Scala"},{"location":"scala/#evaluation-rules","text":"def defines a method val defines a fixed value, it is immmutable and eagerly initialized var defines a variable reference, it is mutable and it should be avoided lazy only initialised when required and as late as possible (deferred evaluation), default is strict and is not recomputed like by-name parameters def myFunction = 2 // evaluated when called val myImmutableValue = 2 // evaluated immediately lazy val iMLazy = 2 // evaluated once when needed def sort ( x : List [ Double ]) // call by value def sort ( x : => List [ Double ]) // call by name // ds is a sequence of Double, containing a varying number of arguments def varargsFunction ( ds : Double* ) = ??? Call by-value : evaluates the function arguments before calling the function Call by-name : evaluates the function first, and then evaluates the arguments if need be (each time the parameter is referenced inside the function)","title":"Evaluation rules"},{"location":"scala/#type-parameters","text":"Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions. class TypedClass [ F ]( arg1 : F ) { ??? } new TypedClass [ Int ]( 1 ) new TypedClass ( 1 ) // the type is being inferred, i.e. determined based on the value arguments Conventionally, the type parameters are expressed using uppercase letters (e.g. A, B, T, F ). It's also possible to restrict the type being used, e.g. def func [ T <: TopLevel ]( arg : T ) : T = { ... } // T must derive from TopLevel or be TopLevel def func [ T >: Level1 ]( arg : T ) : T = { ... } // T must be a supertype of Level1 def func [ T >: Level1 <: Top Level ]( arg : T ) : T = { ... }","title":"Type Parameters"},{"location":"scala/#variance","text":"Quote Variance being a tricky business, users usually get it wrong , and they come away thinking that wildcard and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available. - Programming in Scala Upper Bounds: [S <: T] means: S is a subtype of T. Let's suppose that T is actually an Iterable , then S could one of Seq , List or Iterable . Lower Bounds: [S >: T] means: S is a supertype of T, or T is a subtype of S. So, if T is a List , S could be one of List , Seq , Iterable , or AnyRef . Mixed Bounds: [S >: T2 <: T1] means: s is any type on interval between T1 and T2. In this case we have basically a mix of the two cases above. Let's consider NonEmpty <: IntSet , then can we infer that List[NonEmpty] <: List[IntSet] ? Intuitively, this makes sense: a list of non-empty sets is a special case of a list of arbitrary sets. We call types for which this relationship holds covariant because their subtyping relationship varies with the type parameter. Thus Lists in scala are covariant . Does covariance make sense for all types, not just for List? No. For instance, in Scala, arrays are not covariant . When does it make sense to subtype one type with another? It is safe to assume that a type T is a subtype of a type U ( T <: U ) if you can substitute a value of type T wherever a value of type U is required. This is called the Liskov Substitution Principle . Liskov Substitution Principle https://twitter.com/javi/status/1004821965868109824 Say C[T] is a parameterized type, and A, B are types such that: Given A <: B (A is a subtype of B) If C[A] <: C[B] , C is covariant If C[A] >: C[B] , C is contravariant Neither C[A] or C[B] is a subtype of the other, then C is invariant (or \"nonvariant\" ). Scala lets you declare the variance of a type by annotating the type parameter: class C [ +A ] { ... } // C is covariant class C [ -A ] { ... } // C is contravariant class C [ A ] { ... } // C is invariant So, given that Any > AnyRef > IntSet > Empty and NonEmpty , if type A = IntSet => NonEmpty type B = NonEmpty => IntSet According to the Liskov Principle => A <: B , since B can return an Empty or NonEmpty, but A can return only NonEmpty. For a function, if A2 <: A1 and B1 <: B2 , then A1 => B1 <: A2 => B2 . The consequence is that functions must be contravariant in their argument types and covariant in their result types . /** The Scala Function1 S => T */ trait Function1 [ -S , +T ] { // S is contravariant, while T is covariant def apply ( x : S ) : T } This example shows that functions are contravariant in argument types and covariant in return types. package io.github.sentenza.cars class Car {} class SportsCar extends Car {} class Ferrari extends SportsCar {} object morecovariance extends App { // Test 1: Works as expected def test1 ( arg : SportsCar => SportsCar ) = { new SportsCar } def foo1 ( arg : Car ) : Ferrari = { new Ferrari } def foo2 ( arg : SportsCar ) : Car = { new Ferrari } def foo3 ( arg : Ferrari ) : Ferrari = { new Ferrari } test1 ( foo1 ) // compiles test1 ( foo2 ) // Fails due to wrong return type. test1 ( foo3 ) // Fails due to wrong parameter type } Find out more about variance in Covariance And Contravariance in Scala Type constructor and Variance Abstract To be added pag. 392 of the White Scala Manual","title":"Variance"},{"location":"scala/#objects-and-code-organization","text":"Quote Scala has no globally visible methods: every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods. From Programming in Scala - Second edition (by M. Odersky, L. Spoon, B. Venners) As you can read above, I introduced Objects in terms of the functions they contain . It's very important to stress on this aspect, because Classes and Objects should be seen under a different light using Scala, especially if you come from an imperative OOP language, like Java or C++. They are just a way to organise your functions and at some point, using traits, objects (companion objects) and case classes (data constructors) you will eventually be able to build up your coding architecture based on types and composition of functions. About Case Class","title":"Objects and Code organization"},{"location":"scala/#general-object-hierarchy","text":"Note All members of packages scala and java.lang as well as all members of the object scala.Predef are automatically imported. scala.Nothing is a trait that is the bottom subtype of every subtype of scala.Any scala.Any base type of all types. It has methods hashCode and toString that can be overridden scala.AnyVal is the base type of all primitive types: Double , Float , etc. scala.AnyRef base type of all reference types. (alias of java.lang.Object , supertype of java.lang.String , scala.List , any user-defined class) scala.Null is a subtype of any scala.AnyRef , and scala.Nothing is a subtype of any other type without any instance. Null is a trait and is the bottom type similiar to Nothing but only for AnyRef not AnyVal null is the only instance of type Null Nil is an empty list that is defined as a List[Nothing] None is an empty option that is defined as a Option[Nothing] Unit is a subtype of AnyVal , it's only value is () and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void","title":"General object hierarchy"},{"location":"scala/#factory-object","text":"The following example has been taken from Programming in Scala : abstract class Element { def contents : Array [ String ] def height : Int = contents . length def width : Int = if ( height == 0 ) 0 else contents ( 0 ). length } class ArrayElements ( val contents : Array [ String ]) extends Element // Invoking superclass constructor while extending the class itself class LineElement ( s : String ) extends ArrayElement ( Array ( s )) { override def width = s . length // Int is inferred override def width = 1 } class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } Now, what we can do is defining a Factory Object which contains methods that construct other objects, without exposing each class implementation. Basically, we can hide each class inside a Singleton Object, which will represent just a tag for the overloaded methods that will give us the ability to instantiate each subclass dinamically, and using polymorphism at the same time. Important Note that OOP is not a paradigm, but it's just a way to define our code structure in a logic manner that is similar to playing with LEGOs. OOP can be seen like an orthogonal dimension compared to functional, declarative or imperative paradigms. // We start defining a Singleton Object object Element { // we can now hide classes as private fields of this object private class ArrayElements ( val contents : Array [ String ] ) extends Element private class LineElement ( s : String ) extends Element { val contents = Array ( s ) override def width = s . length override def width = 1 } private class UniformElement ( ch : Char , override val width : Int , override val heigth : Int ) extends Element { private val line = ch . toString * width def contents = Array . fill ( height )( line ) } // FACTORY def elem ( contents : Array [ String ]) : Element = new ArrayElement ( contents ) def elem ( chr : Char , width : Int , heigth : Int ) : Element = new UniformElement ( chr , width , height ) def elem ( line : String ) : Elem = new LineElement ( line ) } Objects creation are centralized and the details now are hidden. Open/Closed Principle This will eventually give an easy way to understand how to use these elements, and at the same time this small change will give the developer the Open/Closed Principle for free because less detail is exposed. \u201cSoftware entities \u2026 should be open for extension, but closed for modification.\u201d This provides more opportunities to change the implementation of the library without breaking client code . At the same time a class will have a single responsibility, and only one potential change in the software\u2019s specification should be able to affect the specification of the class ( Single Responsibility Principle ). So, writing SOLID code pays off at the end.","title":"Factory Object"},{"location":"scala/#factory-method","text":"In Java you can create a private constructor by making it private . In Scala one can achieve the same behaviour prepending the private modifier to the default constructor. class Point private ( coordX : Float , coordY : Float ) { val x = coordX val y = coordY /** Public auxiliary constructor * Setting the point at the origin of the Cartesian axes * calling the default private constructor using the */ def this () = this ( 0.0 , 0.0 ) def getPoint = ( x , y ) } You cannot instantiate a new point using the default constructor: val errorPoint = new Point ( 45.9 , 21.08 ) // ERROR val correctPoint = new Point () // (0.0, 0.0) A possible solution to define a new Point is given by the usage of a companion object and a factory method that will give us a convenient way to define a new object, without actually call the new operator. To do so one can add the apply() method to the newly created object, which will have the same acess rights to the Point class if placed in the same file. Therefore, the apply() method will be able to use the private construction of the Point class and then it will become a factory method : class Point [ T <: Double ] private ( coordX : T , coordY : T ) { ... } object Point { def apply [ T <: Double ]( x : T , y : T ) = new Point [ T ]( x , y ) }","title":"Factory method"},{"location":"scala/#collections","text":"Scala defines several collection classes:","title":"Collections"},{"location":"scala/#base-classes","text":"Iterable (collections you can iterate on) Seq (ordered sequences) Set Map (lookup data structure)","title":"Base Classes"},{"location":"scala/#immutable-collections","text":"List (linked list, provides fast sequential access) Stream (same as List, except that the tail is evaluated only on demand) Vector (array-like type, implemented as tree of blocks, provides fast random access) Range (ordered sequence of integers with equal spacing) String (Java type, implicitly converted to a character sequence, so you can treat every string like a Seq[Char] ) Map (collection that maps keys to values) Set (collection without duplicate elements)","title":"Immutable Collections"},{"location":"scala/#mutable-collections","text":"Array (Scala arrays are native JVM arrays at runtime, therefore they are very performant) Scala also has mutable maps and sets; these should only be used if there are performance issues with immutable types","title":"Mutable Collections"},{"location":"scala/#collections-snippet","text":"Snippet val r : Range = 1 until 5 // 1, 2, 3, 4 val s : Range = 1 to 5 // 1, 2, 3, 4, 5 1 to 10 by 3 // 1, 4, 7, 10 6 to 1 by - 2 // 6, 4, 2 // Operations on sequences val xs = List (...) xs . length // number of elements, complexity O(n) xs . last // last element (exception if xs is empty), complexity O(n) xs . init // all elements of xs but the last (exception if xs is empty), complexity O(n) xs take n // first n elements of xs xs drop n // the rest of the collection after taking n elements xs ( n ) // the nth element of xs, complexity O(n) xs ++ ys // concatenation, complexity O(n) xs . reverse // reverse the order, complexity O(n) xs updated ( n , x ) // same list than xs, except at index n where it contains x, complexity O(n) xs indexOf x // the index of the first element equal to x (-1 otherwise) xs contains x // same as xs indexOf x >= 0 xs filter p // returns a list of the elements that satisfy the predicate p xs filterNot p // filter with negated p xs partition p // same as (xs filter p, xs filterNot p) xs takeWhile p // the longest prefix consisting of elements that satisfy p xs dropWhile p // the remainder of the list after any leading element satisfying p have been removed xs span p // same as (xs takeWhile p, xs dropWhile p) List ( x1 , ..., xn ) reduceLeft op // (...(x1 op x2) op x3) op ...) op xn List ( x1 , ..., xn ). foldLeft ( z )( op ) // (...( z op x1) op x2) op ...) op xn List ( x1 , ..., xn ) reduceRight op // x1 op (... (x{n-1} op xn) ...) List ( x1 , ..., xn ). foldRight ( z )( op ) // x1 op (... ( xn op z) ...) xs exists p // true if there is at least one element for which predicate p is true xs forall p // true if p(x) is true for all elements xs zip ys // returns a list of pairs which groups elements with same index together xs unzip // opposite of zip: returns a pair of two lists xs . flatMap f // applies the function to all elements and concatenates the result xs . sum // sum of elements of the numeric collection xs . product // product of elements of the numeric collection xs . max // maximum of collection xs . min // minimum of collection xs . flatten // flattens a collection of collection into a single-level collection xs groupBy f // returns a map which points to a list of elements xs distinct // sequence of distinct entries (removes duplicates) x +: xs // creates a new collection with leading element x xs :+ x // creates a new collection with trailing element x // Operations on maps val myMap = Map ( \"I\" -> 1 , \"V\" -> 5 , \"X\" -> 10 ) // create a map myMap ( \"I\" ) // => 1 myMap ( \"A\" ) // => java.util.NoSuchElementException myMap get \"A\" // => None myMap get \"I\" // => Some(1) myMap . updated ( \"V\" , 15 ) // returns a new map where \"V\" maps to 15 (entry is updated) // if the key (\"V\" here) does not exist, a new entry is added // Operations on Streams val xs = Stream ( 1 , 2 , 3 ) val xs = Stream . cons ( 1 , Stream . cons ( 2 , Stream . cons ( 3 , Stream . empty ))) // same as above ( 1 to 1000 ). toStream // => Stream(1, ?) x #:: xs // Same as Stream.cons(x, xs) // In the Stream's cons operator, the second parameter (the tail) // is defined as a \"call by name\" parameter. // Note that x::xs always produces a List","title":"Collections snippet"},{"location":"scala/#pairs-similar-for-larger-tuples","text":"val pair = ( \"answer\" , 42 ) // type: (String, Int) val x = ( \"x\" -> 90 ) // type: (String, Int) val y = ( \"y\" -> - 5 ) // type: (String, Int) val z = ( \"z\" -> 0 ) // type: (String, Int) val ( label , value ) = pair // label = \"answer\", value = 42 pair . _1 // \"answer\" pair . _2 // 42","title":"Pairs (similar for larger Tuples)"},{"location":"scala/#ordering","text":"There is already a class in the standard library that represents orderings: scala.math.Ordering[T] which contains comparison functions such as lt() and gt() for standard types. Types with a single natural ordering should inherit from the trait scala.math.Ordered[T] . import math.Ordering def msort [ T ]( xs : List [ T ])( implicit ord : Ordering ) = { ...} msort ( fruits )( Ordering . String ) msort ( fruits ) // the compiler figures out the right ordering","title":"Ordering"},{"location":"scala/#typeclass","text":"Quote [...] Type class is a class (group) of types, which satisfy some contract defined in a trait with addition that such functionality (trait and implementation) can be added without any changes to the original code. One could say that the same could be achieved by extending a simple trait, but with type classes it is not necessary to predict such a need beforehand. There is no special syntax in Scala to express a type class, but the same functionality can be achieved using constructs that already exist in the language. **That\u2019s what makes it a little difficult for newcomers to spot a type class in code. A typical implementation of a type class uses some syntactic sugar as well, which also doesn\u2019t make it clear right away what we are dealing with* .* https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html","title":"Typeclass"},{"location":"scala/#sbt","text":"Defining dependencies and Settins in /project","title":"SBT"}]}